<?xml version="1.0"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>CÃ©dric Champeau's blog</title>
    <link>https://melix.github.io/blog/</link>
    <atom:link href="https://melix.github.io/blog//feed.xml" rel="self" type="application/rss+xml" />
    <description>JBake Bootstrap Template</description>
    <language>en-gb</language>
    <pubDate>Sun, 11 Apr 2021 14:16:50 +0200</pubDate>
    <lastBuildDate>Sun, 11 Apr 2021 14:16:50 +0200</lastBuildDate>

    <item>
      <title>Frequently asked questions about version catalogs</title>
      <link>https://melix.github.io/blog/2021/03/version-catalogs-faq.html</link>
      <pubDate>Sun, 11 Apr 2021 00:00:00 +0200</pubDate>
      <guid isPermaLink="false">2021/03/version-catalogs-faq.html</guid>
      	<description>
	&lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This post is a follow up to my &lt;a href=&quot;/blog/2021/03/version-catalogs.html&quot;&gt;version catalogs intro blog post&lt;/a&gt; and answers some frequently asked questions.
Ideally, this should be part of the Gradle docs itself but we don&amp;#8217;t have a good place for this kind of docs yet (I&amp;#8217;m working on it!), so in the meantime, here you go!
This blog post will be updated as I&amp;#8217;m seeing more questions.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;toc&quot; class=&quot;toc&quot;&gt;
&lt;div id=&quot;toctitle&quot; class=&quot;title&quot;&gt;Table of Contents&lt;/div&gt;
&lt;ul class=&quot;sectlevel1&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_version_catalogs_faq&quot;&gt;Version catalogs FAQ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ul class=&quot;sectlevel2&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_can_i_use_a_version_catalog_to_declare_plugin_versions&quot;&gt;Can I use a version catalog to declare plugin versions?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_can_i_use_the_version_catalog_in_buildsrc&quot;&gt;Can I use the version catalog in buildSrc?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_but_how_can_i_use_the_catalog_in_em_plugins_em_defined_in_code_buildsrc_code&quot;&gt;But how can I use the catalog in &lt;em&gt;plugins&lt;/em&gt; defined in &lt;code&gt;buildSrc&lt;/code&gt;?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_can_i_use_version_catalogs_in_production_code&quot;&gt;Can I use version catalogs in production code?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_you_i_use_a_platform_or_a_catalog&quot;&gt;You I use a platform or a catalog?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_why_did_you_choose_toml_and_not_yaml&quot;&gt;Why did you choose TOML and not YAML?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_my_ide_is_red_everywhere_missing_dependency_class_error&quot;&gt;My IDE is red everywhere, MISSING_DEPENDENCY_CLASS error&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_why_can_t_i_have_nested_aliases_with_the_same_prefix&quot;&gt;Why can&amp;#8217;t I have nested aliases with the same prefix?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_why_can_t_i_use_an_alias_with_dots_directly&quot;&gt;Why can&amp;#8217;t I use an alias with dots directly?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_should_i_use_code_commons_lang3_code_as_an_alias_or_code_commonslang3_code&quot;&gt;Should I use &lt;code&gt;commons-lang3&lt;/code&gt; as an alias or &lt;code&gt;commonsLang3&lt;/code&gt;?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_should_i_use_the_settings_api_or_the_toml_file&quot;&gt;Should I use the settings API or the TOML file?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_version_catalogs_faq&quot;&gt;Version catalogs FAQ&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_can_i_use_a_version_catalog_to_declare_plugin_versions&quot;&gt;Can I use a version catalog to declare plugin versions?&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;No.The initial implementation of the version catalogs had, in TOML files, a dedicated section for plugins:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint toml language-toml&quot;&gt;&lt;code&gt;[plugins]
id.of.my.awesome.plugin=&quot;1.2.3&quot;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;However, after community feedback and for &lt;a href=&quot;https://github.com/gradle/gradle/issues/16078&quot;&gt;consistency reasons&lt;/a&gt;, we removed this feature from the initial release.
This means that &lt;em&gt;currently&lt;/em&gt;, you have to use the &lt;code&gt;pluginManagement&lt;/code&gt; section of the settings file to deal with your plugin versions, and this cannot use, in particular, the TOML file to declare plugin versions:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;settings.gradle&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;pluginManagement {
    plugins {
        id(&quot;me.champeau.jmh&quot;) version(&quot;0.6.3&quot;)
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;It may look surprising that you can&amp;#8217;t use &lt;code&gt;version(libs.plugins.jmh)&lt;/code&gt; for example in the &lt;code&gt;pluginManagement&lt;/code&gt; block, but it&amp;#8217;s a chicken and egg problem: the &lt;code&gt;pluginManagement&lt;/code&gt; block has to be evaluated &lt;em&gt;before&lt;/em&gt; the catalogs are defined, because &lt;em&gt;settings plugins&lt;/em&gt; may contribute more catalogs or enhance the existing catalogs. Therefore, the &lt;code&gt;libs&lt;/code&gt; extension doesn&amp;#8217;t exist when this block is evaluated.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The limitation of not being able to deal with plugin versions in catalogs will be lifted in one way or another in the future.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_can_i_use_the_version_catalog_in_buildsrc&quot;&gt;Can I use the version catalog in buildSrc?&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Yes you can. Not only in &lt;code&gt;buildSrc&lt;/code&gt;, but basically in any included build too. You have several options, but the easiest is to include the TOML catalog in your &lt;code&gt;buildSrc/settings.gradle(.kts)&lt;/code&gt; file:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;buildSrc/settings.gradle&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;dependencyResolutionManagement {
    versionCatalogs {
        lib {
            from(files(&quot;../gradle/libs.versions.toml&quot;))
        }
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_but_how_can_i_use_the_catalog_in_em_plugins_em_defined_in_code_buildsrc_code&quot;&gt;But how can I use the catalog in &lt;em&gt;plugins&lt;/em&gt; defined in &lt;code&gt;buildSrc&lt;/code&gt;?&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The solution above lets you use the catalogs in the build scripts of &lt;code&gt;buildSrc&lt;/code&gt; itself, but what if you want to use the catalog(s) in the plugins that &lt;code&gt;buildSrc&lt;/code&gt; defines, or precompiled script plugins?
Long story short, currently, you can do it using a &lt;em&gt;type unsafe&lt;/em&gt; API only.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;First you need to access the version catalogs extension to your plugin/build script, for example in Groovy:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;def catalogs = project.extensions.getByType(VersionCatalogsExtension)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;or in Kotlin:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint kotlin language-kotlin&quot;&gt;&lt;code&gt;val catalogs = extensions.getByType&amp;lt;VersionCatalogsExtension&amp;gt;()&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;then you can access the version catalogs in your script, for example writing:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint kotlin language-kotlin&quot;&gt;&lt;code&gt;pluginManager.withPlugin(&quot;java&quot;) {
    val libs = catalogs.named(&quot;libs&quot;)
    dependencies.addProvider(&quot;implementation&quot;, libs.findDependency(&quot;lib&quot;).get())
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Note that this API doesn&amp;#8217;t provide any static accessor but is nevertheless safe, using the &lt;code&gt;Optional&lt;/code&gt; API.
There&amp;#8217;s a reason why you cannot access type-safe accessors in plugins/precompiled script plugins, you will find more details on this &lt;a href=&quot;https://github.com/gradle/gradle/issues/15383&quot;&gt;issue&lt;/a&gt;.
In a nutshell, that&amp;#8217;s because &lt;code&gt;buildSrc&lt;/code&gt; plugins (precompiled or not) are &lt;em&gt;plugins&lt;/em&gt; which can be applied to any kind of project and we don&amp;#8217;t know what the &lt;em&gt;target project catalogs&lt;/em&gt; will be: there&amp;#8217;s no inherent reason why they would be the same.
In the future we will probably provide a way to explain that, at your own risk, expect the target catalog model to be the same.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_can_i_use_version_catalogs_in_production_code&quot;&gt;Can I use version catalogs in production code?&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;No, you can&amp;#8217;t. Version catalogs are only accessible to build scripts/plugins, not your production code.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_you_i_use_a_platform_or_a_catalog&quot;&gt;You I use a platform or a catalog?&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;You should probably use both, look at our &lt;a href=&quot;https://docs.gradle.org/7.0/userguide/platforms.html#sub:platforms-vs-catalog&quot;&gt;docs&lt;/a&gt; for a complete explanation.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_why_did_you_choose_toml_and_not_yaml&quot;&gt;Why did you choose TOML and not YAML?&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;or XML (or pick your favorite format). The rationale is described in the &lt;a href=&quot;https://github.com/gradle/gradle/files/5646826/2020-12-05-Central.declaration.of.dependencies.Shared.externally.pdf&quot;&gt;design document&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_my_ide_is_red_everywhere_missing_dependency_class_error&quot;&gt;My IDE is red everywhere, MISSING_DEPENDENCY_CLASS error&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;If you are seeing this error:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;/blog/img/missing-dependency.png&quot; alt=&quot;missing dependency&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;upgrade to the latest IntelliJ IDEA 2021.1, which fixes this problem.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_why_can_t_i_have_nested_aliases_with_the_same_prefix&quot;&gt;Why can&amp;#8217;t I have nested aliases with the same prefix?&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Imagine that you want to have 2 aliases, say &lt;code&gt;junit&lt;/code&gt; and &lt;code&gt;junit-jupiter&lt;/code&gt; and that both represent distinct dependencies: Gradle won&amp;#8217;t let you do this and you will have to rename your aliases to, say &lt;code&gt;junit-core&lt;/code&gt; and &lt;code&gt;junit-jupiter&lt;/code&gt;.
That&amp;#8217;s because Gradle will map those aliases to &lt;em&gt;accessors&lt;/em&gt;, that is to say &lt;code&gt;libs.getJunit()&lt;/code&gt; and &lt;code&gt;libs.getUnit().getJupiter()&lt;/code&gt;.
The problem is that you can&amp;#8217;t have an accessor which is both a &lt;em&gt;leaf&lt;/em&gt; (represents a dependency notation) and a &lt;em&gt;node&lt;/em&gt; (that is to say an intermediate node to access a real dependency).
The reason we can&amp;#8217;t do this is that we&amp;#8217;re using lazy accessors of type &lt;code&gt;Provider&amp;lt;MinimalExternalDependency&amp;gt;&lt;/code&gt; for leaves and that type &lt;em&gt;cannot&lt;/em&gt; be extended to provide accessors for &quot;children&quot; dependencies.
In other words, the type which represents a &lt;em&gt;node with children&lt;/em&gt; provides accessors which return &lt;code&gt;Provider&amp;lt;...&amp;gt;&lt;/code&gt; for dependencies, but a provider itself cannot have children.
A potential workaround for this would be to support, in the future, an explicit call to say &quot;I&amp;#8217;m stopping here, that&amp;#8217;s the dependency I need&quot;, for example:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;dependencies {
    testImplementation(libs.junit.get())
    // or
    testImplemementation(libs.junit.peek()) // because `get()` might be confusing as it would return a `Provider` on which you can call `get()` itself
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;For now the team has decided to restrict what you can do by preventing having aliases which have &quot;name clashes&quot;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_why_can_t_i_use_an_alias_with_dots_directly&quot;&gt;Why can&amp;#8217;t I use an alias with dots directly?&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;You will have noticed that if you declare an alias like this:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint toml language-toml&quot;&gt;&lt;code&gt;[libraries]
junit-jupiter = &quot;...&quot;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;then Gradle will generate the following accessor: &lt;code&gt;libs.junit.jupiter&lt;/code&gt; (basically the dashes are transformed to dots).
The question is, why can&amp;#8217;t we just write:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint toml language-toml&quot;&gt;&lt;code&gt;[libraries]
junit.jupiter = &quot;...&quot;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;And the reason is: tooling support. The following declaration is actually equivalent to writing:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint toml language-toml&quot;&gt;&lt;code&gt;[libraries]
   [junit]
   jupiter = &quot;...&quot;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;but technically, it&amp;#8217;s undecidable where the &quot;nesting hierarchy&quot; stops, which would prevent tools from providing good completion (for example, where you can use &lt;code&gt;{ module = &quot;...&quot;}&lt;/code&gt;.
It also makes it harder for tooling to automatically patch the file since they wouldn&amp;#8217;t know where to look for.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;As a consequence, we&amp;#8217;ve decided to keep the format simple and implement this mapping strategy.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_should_i_use_code_commons_lang3_code_as_an_alias_or_code_commonslang3_code&quot;&gt;Should I use &lt;code&gt;commons-lang3&lt;/code&gt; as an alias or &lt;code&gt;commonsLang3&lt;/code&gt;?&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Problably neither one nor the other :) By choosing &lt;code&gt;commons-lang3&lt;/code&gt;, you&amp;#8217;re implicitly creating a &lt;em&gt;group of dependencies` called _commons&lt;/em&gt;, which will include a number of dependencies, including &lt;code&gt;lang3&lt;/code&gt;.
The question then is, does that &lt;code&gt;commons&lt;/code&gt; group make sense? It&amp;#8217;s rather abstract, no? Does it actually say it&amp;#8217;s &quot;Apache Commons&quot;?&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;A better solution would therefore to use &lt;code&gt;commonsLang3&lt;/code&gt; as the alias, but then you&amp;#8217;d realize that you have chosen a version in the alias name, so why not &lt;code&gt;commonsLang&lt;/code&gt; directly?&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Therefore:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint toml language-toml&quot;&gt;&lt;code&gt;[libraries]
commonsLang = { module=&quot;org.apache.commons:commons-lang3:3.3.1&quot; }&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This means that the dashes should be limited to grouping of dependencies, so that they are organized in &quot;folders&quot;.
This can make it practical when you have lots of dependencies, but it also makes them less discoverable by completion, since you&amp;#8217;d have to know in why subtree to look at.
Proper guidance on what to use will be discussed later, based on your feedback and practices.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_should_i_use_the_settings_api_or_the_toml_file&quot;&gt;Should I use the settings API or the TOML file?&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Gradle comes with both a settings API to declare the catalog, or a convenience TOML file.
I would personally say that most people should only care about the TOML file as it covers 80% of use cases.
The settings API is great as soon as you want to implement &lt;em&gt;settings plugins&lt;/em&gt; or, for example, that you want to use your own, existing format to declare a catalog, instead of using the TOML format.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>Simplified version management with Gradle 7</title>
      <link>https://melix.github.io/blog/2021/03/version-catalogs.html</link>
      <pubDate>Wed, 24 Mar 2021 00:00:00 +0100</pubDate>
      <guid isPermaLink="false">2021/03/version-catalogs.html</guid>
      	<description>
	&lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Gradle 7 introduces the concept of &lt;a href=&quot;https://docs.gradle.org/7.0-rc-1/userguide/platforms.html&quot;&gt;version catalogs&lt;/a&gt;, which I&amp;#8217;ve been working on for several months already. Long story short, I&amp;#8217;m extremely excited by this new feature which should make dependency management easier with Gradle. Let&amp;#8217;s get started!&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;em&gt;Please also read my &lt;a href=&quot;/blog/2021/03/version-catalogs-faq.html&quot;&gt;Version catalogs FAQ&lt;/a&gt; follow up post if you have more questions!&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_sharing_dependencies_between_projects&quot;&gt;Sharing dependencies between projects&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;One of the most frequent questions raised by Gradle users is how to properly share dependency versions between projects.
For example, let&amp;#8217;s imagine that you have a multi-project build with this layout:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;root
 |---- client
 |---- server&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Because they live in the same &quot;multi-project&quot;, it is expected that both &lt;code&gt;client&lt;/code&gt; and &lt;code&gt;server&lt;/code&gt; would require the same dependencies.
For example, both of them would need Guava as an implementation detail and JUnit 5 for testing:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;build.gradle&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;dependencies {
    implementation(&quot;com.google.guava:guava:30.0-jre&quot;)
    testImplementation(&quot;org.junit.jupiter:junit-jupiter-api:5.7.1&quot;)
    testRuntimeOnly(&quot;org.junit.jupiter:junit-jupiter-engine&quot;)
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Without any sharing mechanism, both projects would replicate the dependency declarations, which is subject to a number of drawbacks:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;upgrading a library requires updating all build files which use it&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;you have to remember about the dependency coordinates (group, artifact, version) of all dependencies&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;you might accidentally use different versions in different projects&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;some dependencies are always used together but you have to duplicate entries in build files&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_existing_patterns&quot;&gt;Existing patterns&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;For these reasons, users have invented over the years different patterns for dealing with dependency versions over time.
For example:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Versions in properties files:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;gradle.properties&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;guavaVersion=30.0-jre&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;then in a build file:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;dependencies {
    implementation(&quot;com.google.guava:guava:${guavaVersion}&quot;)
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Or versions in &quot;extra properties&quot; in the root project:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;extra properties&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;ext {
   guavaVersion = &apos;30.0-jre&apos;
}

// ...

dependencies {
    implementation(&quot;com.google.guava:guava:${guavaVersion}&quot;)
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Sometimes you even find full coordinates in &lt;code&gt;dependencies.gradle&lt;/code&gt; files.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;And since the rise of the Kotlin DSL, another pattern became extremely popular in the Android world: declaring libraries in &lt;code&gt;buildSrc&lt;/code&gt; then using type-safe accessors to declare dependencies in build scripts:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;buildSrc/src/main/kotlin/Libs.kt&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint kotlin language-kotlin&quot;&gt;&lt;code&gt;object Libs {
   val guava = &quot;com.google.guava:guava:30.0-jre&quot;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;and in a build script:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;build.gradle&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;dependencies {
    implementation(Libs.guava)
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This last example is interesting because it goes into the direction of having more type-safety, more compile-time errors (as opposed to runtime errors).
But it has a major drawback: any change to any dependency will trigger recompilation of build scripts and invalidate the build script classpath, causing up-to-date checkness to fail and in the end, rebuilding a lot more than what you should do for a single version change.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_introducing_version_catalogs&quot;&gt;Introducing version catalogs&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;A version catalog is basically a replacement for all the previous patterns, supported by Gradle, without the drawbacks of the previous approaches.
To add support for version catalogs, you need to enable the experimental feature in your settings file:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;settings.gradle&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;enableFeaturePreview(&quot;VERSION_CATALOGS&quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In its simplest form, a catalog is a file found in a conventional location and uses the &lt;a href=&quot;https://toml.io/en/&quot;&gt;TOML&lt;/a&gt; configuration format:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;gradle/libs.versions.toml&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint toml language-toml&quot;&gt;&lt;code&gt;[libraries]
guava = &quot;com.google.guava:guava:30.0-jre&quot;
junit-jupiter = &quot;org.junit.jupiter:junit-jupiter-api:5.7.1&quot;
junit-engine = { module=&quot;org.junit.jupiter:junit-jupiter-engine&quot; }

[bundles]
testDependencies = [&quot;junit-jupiter&quot;, &quot;junit-engine&quot;]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This declares the &lt;em&gt;dependency coordinates&lt;/em&gt; which will be used in build scripts.
You still have to declare your dependencies, but this now can be done using a &lt;em&gt;typesafe&lt;/em&gt; API:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;build.gradle&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;dependencies {
    implementation(libs.guava)
    testImplementation(libs.testDependencies)
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The benefit of type-safe APIs is immediately visible in the IDE:&lt;/p&gt;
&lt;/div&gt;
&lt;video controls autoplay height=&quot;450&quot;&gt;
    &lt;source src=&quot;/blog/video/ide-completion.webm&quot;
            type=&quot;video/webm&quot;&gt;
&lt;/video&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In the catalog file above, we inlined dependency versions directly in the coordinates.
However, it&amp;#8217;s possible to externalize them so that you can share a dependency version between dependencies.
For example:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;gradle/libs.versions.toml&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint toml language-toml&quot;&gt;&lt;code&gt;[versions]
groovy = &quot;2.5.14&quot;
guava = &quot;30.0-jre&quot;
jupiter = &quot;5.7.1&quot;

[libraries]
guava = { module=&quot;com.google.guava:guava&quot;, version.ref=&quot;guava&quot; }
junit-jupiter = { module=&quot;org.junit.jupiter:junit-jupiter-api&quot;, version.ref=&quot;jupiter&quot; }
junit-engine = { module=&quot;org.junit.jupiter:junit-jupiter-engine&quot; }

groovy-core = { module=&quot;org.codehaus.groovy:groovy&quot;, version.ref=&quot;groovy&quot; }
groovy-json = { module=&quot;org.codehaus.groovy:groovy-json&quot;, version.ref=&quot;groovy&quot; }

[bundles]
testDependencies = [&quot;junit-jupiter&quot;, &quot;junit-engine&quot;]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This new feature makes it trivial to update a dependency version: you have a single place where to look at.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This comes with other benenefits like the fact that updating the GAV coordinates (group, artifact or version) of a dependency doesn&amp;#8217;t trigger recompilation of build scripts.
The TOML format also provides us with the ability to declare &lt;a href=&quot;https://docs.gradle.org/7.0-rc-1/userguide/rich_versions.html&quot;&gt;rich versions&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_under_the_hood&quot;&gt;Under the hood&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Under the hood, Gradle provides an API to declare catalogs. This API is found on the &lt;code&gt;Settings&lt;/code&gt;, which means that plugin authors can contribute catalogs, for example via convention plugins applied to the &lt;code&gt;settings.gradle(.kts)&lt;/code&gt; file.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This API is more verbose than when you use the TOML file, but is designed for type-safety. The equivalent of the catalog above would be this:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;settings.gradle&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;dependencyResolutionManagement {
   versionCatalogs {
      libs {
           alias(&quot;guava&quot;).to(&quot;com.google.guava&quot;, &quot;guava&quot;).versionRef(&quot;guava&quot;)
           alias(&quot;junit-jupiter&quot;).to(&quot;org.junit.jupiter&quot;, &quot;junit-jupiter-api&quot;).versionRef(&quot;jupiter&quot;)
           alias(&quot;junit-engine&quot;).to(&quot;org.junit.jupiter&quot;, &quot;junit-jupiter-engine&quot;).withoutVersion()
           alias(&quot;groovy-core&quot;).to(&quot;org.codehaus.groovy&quot;, &quot;groovy&quot;).versionRef(&quot;groovy&quot;)
           alias(&quot;groovy-json&quot;).to(&quot;org.codehaus.groovy&quot;, &quot;groovy-json&quot;).versionRef=&quot;groovy&quot;)

           version(&quot;groovy&quot;, &quot;2.5.14&quot;)
           version(&quot;guava&quot;, &quot;30.0-jre&quot;)
           version(&quot;jupiter&quot;, &quot;5.7.1&quot;)
      }
   }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This API actually must be used if you are &lt;em&gt;consuming an external catalog&lt;/em&gt;.
That&amp;#8217;s one of the big selling points of this feature: it allows teams (or framework authors) to &lt;em&gt;publish catalogs&lt;/em&gt;, so that users can get recommendations.
For example, let&amp;#8217;s imagine that the Spring Boot team &lt;a href=&quot;https://docs.gradle.org/7.0-rc-1/userguide/platforms.html#sec:version-catalog-plugin&quot;&gt;publishes a catalog of recommendations&lt;/a&gt; (they do something similar today with a BOM, but BOMs will have an impact on your transitive dependencies that you might not want).&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Consuming this catalog it in a Gradle build would look like this:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;settings.gradle&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;dependencyResolutionManagement {
   versionCatalogs {
       spring {
           from(&quot;org.springframework:spring-catalog:1.0&apos;)
       }
   }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This would make a catalog available under the &lt;code&gt;spring&lt;/code&gt; namespace in your build scripts.
Therefore, you&amp;#8217;d be able to use whatever version of SLF4J the Spring team recommends by declaring this dependency:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;build.gradle&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;dependencies {
    implementation(spring.slf4j)
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Such a catalog would be published on a regular Maven repository, as a TOML file.
Thanks to Gradle&amp;#8217;s advanced dependency resolution engine, it&amp;#8217;s totally transparent to the user that the actual dependency is a &lt;em&gt;catalog&lt;/em&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_what_version_catalogs_are_not&quot;&gt;What version catalogs are not&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;At this stage, it becomes important to state what version catalogs are &lt;strong&gt;not&lt;/strong&gt;:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;they &lt;strong&gt;are not&lt;/strong&gt; the &quot;single source of truth&quot; for your dependencies: it&amp;#8217;s not because you have a catalog that you can&amp;#8217;t directly declare dependencies using the &quot;old&quot; notation in build scripts. Nor does it prevent plugins from adding dependencies. Long story short: the presence of a catalog makes discoverability and maintenance easier, but it doesn&amp;#8217;t remove any of the flexibility that Gradle offers. We&amp;#8217;re thinking about ways to &lt;em&gt;enforce&lt;/em&gt; that all direct dependencies are declared via a catalog in the future.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;the version declared in a catalog &lt;strong&gt;is not&lt;/strong&gt; necessarily the one which is going to be resolved: a catalog only talks about direct dependencies (not transitives) and the version that you use is the one used as an &lt;em&gt;input&lt;/em&gt; to dependency resolution. With transitive dependencies, it&amp;#8217;s typically possible that a version gets upgraded, for example.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;while it makes it possible for third-party tooling to &quot;update automatically&quot; versions, this wasn&amp;#8217;t a goal of this work. If you relate to the previous point, it all makes sense: as long as you rely on the &lt;em&gt;input&lt;/em&gt; (what is written) to assume what is going to be resolved, you&amp;#8217;re only &lt;em&gt;wishing&lt;/em&gt; that it is what is going to be resolved. It may be enough for some cases, though. Please refer to my &lt;a href=&quot;https://melix.github.io/blog/2020/10/about-dependabot.html&quot;&gt;blog post about Dependabot&lt;/a&gt; for more insights on this topic. Again, future work we have in mind is adding some linting to make sure that the first level dependencies you declare match whatever you resolved, because in general, having a difference there is a sign that something is wrong in the setup. I&amp;#8217;m going to repeat myself, but &lt;strong&gt;don&amp;#8217;t assume that the version you see in a config file is the one you will get&lt;/strong&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Please take a look at the &lt;a href=&quot;https://docs.gradle.org/7.0-rc-1/userguide/platforms.html#sub:central-declaration-of-dependencies&quot;&gt;documentation&lt;/a&gt; for further details, and give us your feedback!&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>Using Java 16 with Gradle</title>
      <link>https://melix.github.io/blog/2021/03/gradle-java16.html</link>
      <pubDate>Wed, 17 Mar 2021 00:00:00 +0100</pubDate>
      <guid isPermaLink="false">2021/03/gradle-java16.html</guid>
      	<description>
	&lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://twitter.com/java/status/1371842658256228356&quot;&gt;Java 16 is out&lt;/a&gt; and I&amp;#8217;m seeing a number of folks trying to figure out how to use Java 16 with Gradle.
Often they would try to run Gradle with JDK 16 and see it fail.
There&amp;#8217;s a &lt;a href=&quot;https://github.com/gradle/gradle/issues/13481&quot;&gt;ticket about Java 16 support in Gradle&lt;/a&gt; but in most cases you can already work with JDK 16 without waiting for official support.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_the_happy_path&quot;&gt;The happy path&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Gradle 7, which is due soon, will provide official support for Java 16.
If you have an existing build that you want to try on Java 16, you can update the wrapper to use the latest Gradle 7.0 milestone release:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;gradle/wrapper/gradle-wrapper.properties&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-7.0-milestone-3-bin.zip
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;If you are lucky this is all you need to do.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;However, Gradle 7 is a major release, and as such it brings a number of changes which &lt;em&gt;may&lt;/em&gt; break your build (deprecated methods being removed, or, in particular for the Java 16 support, upgrading to Groovy 3 internally).
It may be a bit involved to migrate to Gradle 7 just to try Java 16.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_decouple_the_java_version_used_for_gradle_itself_from_the_version_you_need&quot;&gt;Decouple the Java version used for Gradle itself from the version you need!&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;It&amp;#8217;s actually better to &lt;em&gt;decouple the version of Java required to run Gradle&lt;/em&gt; from the &lt;em&gt;version of Java your application requires&lt;/em&gt;.
In general, it&amp;#8217;s actually considered the &lt;strong&gt;best practice&lt;/strong&gt; to use whatever version of the JDK Gradle officially supports to run Gradle itself, and configure the build to &lt;strong&gt;use a different JDK&lt;/strong&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_configuring_java_toolchains&quot;&gt;Configuring Java toolchains&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In Gradle terminology, this is called activating &lt;a href=&quot;https://docs.gradle.org/6.8.3/userguide/toolchains.html&quot;&gt;Java Toolchains&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Let&amp;#8217;s get started with a sample project running on latest stable Gradle, which is 6.8.3.
Make sure that you have Gradle 6.8.3 on your PATH to get started.
I&amp;#8217;m personally recommending to use &lt;a href=&quot;https://sdkman.io/&quot;&gt;sdkman!&lt;/a&gt; to install Gradle:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint bash language-bash&quot;&gt;&lt;code&gt;$ sdk install gradle 6.8.3&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;At the same time, we want to make sure we run Gradle with a supported version, which is anything between Java 8 and 15:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint bash language-bash&quot;&gt;&lt;code&gt;$ java -version
java -version
openjdk version &quot;11.0.9.1&quot; 2020-11-04
OpenJDK Runtime Environment 18.9 (build 11.0.9.1+1)
OpenJDK 64-Bit Server VM 18.9 (build 11.0.9.1+1, mixed mode)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;If it outputs something else than 8 to 15, please make sure to update your PATH to point to such a JDK.
Again you can do this with sdkman!:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint bash language-bash&quot;&gt;&lt;code&gt;$ sdk install java 11.0.9.open&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_demo_application&quot;&gt;Demo application&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Now, let&amp;#8217;s create a sample Gradle project:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint bash language-bash&quot;&gt;&lt;code&gt;$ mkdir demo-app
$ cd demo-app
$ gradle init&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Then select:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;Select type of project to generate:
  1: basic
  2: application
  3: library
  4: Gradle plugin
Enter selection (default: basic) [1..4] 2

Select implementation language:
  1: C++
  2: Groovy
  3: Java
  4: Kotlin
  5: Scala
  6: Swift
Enter selection (default: Java) [1..6] 3

Split functionality across multiple subprojects?:
  1: no - only one application project
  2: yes - application and library projects
Enter selection (default: no - only one application project) [1..2] 1

Select build script DSL:
  1: Groovy
  2: Kotlin
Enter selection (default: Groovy) [1..2] 1

Select test framework:
  1: JUnit 4
  2: TestNG
  3: Spock
  4: JUnit Jupiter
Enter selection (default: JUnit 4) [1..4] 4

Project name (default: demo-app):
Source package (default: demo.app):&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;and confirm the default name and packages.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Then let&amp;#8217;s run our app:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint bash language-bash&quot;&gt;&lt;code&gt;$ ./gradlew run

&amp;gt; Task :app:run
Hello World!

BUILD SUCCESSFUL in 4s
2 actionable tasks: 2 executed&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_migrating_the_application_to_java_16&quot;&gt;Migrating the application to Java 16&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;All good! Now let&amp;#8217;s configure Gradle to use Java 16 to build and run our app instead.
Let&amp;#8217;s open the build script, found under &lt;code&gt;app&lt;/code&gt;:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;app/build.gradle&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;plugins {
    // Apply the application plugin to add support for building a CLI application in Java.
    id &apos;application&apos;
}

// Add this under the `plugins` section:
java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(16)
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The &lt;code&gt;java.toolchain&lt;/code&gt; block lets us configure the &lt;em&gt;toolchain&lt;/em&gt; that Gradle is going to use to build and run your application.
We&amp;#8217;re setting 16, which means that we&amp;#8217;re going to compile the main and test sources as well as execute the with a Java 16 JDK.
Gradle will automatically try to find if you have a Java 16 installation in a conventional location.
If it cannot find one you will see something like this happening:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Provisioning toolchain adoptopenjdk-16-x64-linux.tar.gz &amp;gt; adoptopenjdk-16-x64-linux.tar.gz &amp;gt; 66 MiB/195.8 MiB&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;which means that Gradle is downloading the JDK for you!&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Let&amp;#8217;s check:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint bash language-bash&quot;&gt;&lt;code&gt;./gradlew run&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;strong&gt;Dang!&lt;/strong&gt; The &lt;a href=&quot;https://scans.gradle.com/s/gogpwzdj5zf6q/console-log?anchor=14&quot;&gt;build fails!&lt;/a&gt;.
To some extent, it&amp;#8217;s good news, it means that Gradle is really using Java 16, but why is it failing?&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_disabling_incremental_compilation&quot;&gt;Disabling incremental compilation&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Well, you&amp;#8217;re facing one of the bugs we fixed in 7, which is that our &lt;em&gt;incremental compiler&lt;/em&gt; isn&amp;#8217;t compatible with Java 16 because we&amp;#8217;re using classes which have been made &quot;hidden&quot; by the module system in Java 16.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;There&amp;#8217;s an easy fix: let&amp;#8217;s disable incremental compilation!&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Again, let&amp;#8217;s open our &lt;code&gt;app/build.gradle&lt;/code&gt; file and add this:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;tasks.withType(JavaCompile).configureEach {
	// disable incremental compilation
    options.incremental = false
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;And let&amp;#8217;s run the build again:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint bash language-bash&quot;&gt;&lt;code&gt;./gradlew run&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Yay! This time the &lt;a href=&quot;https://scans.gradle.com/s/czapxbvfqxt72/console-log?anchor=7&quot;&gt;build passed!&lt;/a&gt;
Congrats, you have your first Java 16 app running!&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Alternatively to disabling incremental compilation, you might just want to let Gradle access the JDK internals.
This solution is better for performance, even if a bit &quot;hackish&quot;:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;tasks.withType(JavaCompile).configureEach {
    options.forkOptions.jvmArgs.addAll( [&apos;--add-opens&apos;, &apos;jdk.compiler/com.sun.tools.javac.code=ALL-UNNAMED&apos;] )
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In case you want to use one of the experimental features that Java 16 provides, the setup I&amp;#8217;ve described in a &lt;a href=&quot;https://melix.github.io/blog/2020/06/java-feature-previews-gradle.html&quot;&gt;previous post about Java Feature Previews&lt;/a&gt; still hold and is a good follow-up to this post!&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>Gradle + WebAssembly</title>
      <link>https://melix.github.io/blog/2021/02/gradle-webassembly.html</link>
      <pubDate>Sun, 21 Feb 2021 00:00:00 +0100</pubDate>
      <guid isPermaLink="false">2021/02/gradle-webassembly.html</guid>
      	<description>
	&lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;A couple weeks ago, I listened to an &lt;a href=&quot;https://medium.com/electro-monkeys/64-la-face-cach%C3%A9e-de-webassembly-avec-geoffroy-couprie-et-ivan-enderline-bd20e5482893&quot;&gt;interview (in French)&lt;/a&gt; of &lt;a href=&quot;https://twitter.com/gcouprie&quot;&gt;Geoffroy Couprie&lt;/a&gt; and &lt;a href=&quot;https://twitter.com/mnt_io&quot;&gt;Ivan Enderlin&lt;/a&gt; who gave a very nice overview of what WebAssembly is and what it&amp;#8217;s good for.
To be honest it wasn&amp;#8217;t clear to me what the advantages of WebAssembly were, compared to a good old JVM: all in all, both are virtual machines, and both promise the same thing, that is to say write once run everywhere.
Also, in my mind, WebAssembly was some kind of restricted version of JavaScript like &lt;a href=&quot;https://en.wikipedia.org/wiki/Asm.js&quot;&gt;asm.js&lt;/a&gt;.
I was wrong: it&amp;#8217;s more than that.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_why_webassembly&quot;&gt;Why WebAssembly?&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;One of the aspects which were discussed during this interview was basically sandboxing: with WebAssembly, it&amp;#8217;s the responsibility of the embedder to give access, for example, to I/O to the wasm program. In practice, it means that wasm binaries are by default very restricted.
In fact, by design, they are restricted to pure computations, which makes them very suitable for isolation of work.
Extensions from embedders are responsible for giving access to the host resources (for example the GPU, or the file system).&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Another promise of WebAssembly is running at close-to-native speeds.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Therefore, a crazy idea came to me: what if I could use a wasm binary as a task implemention in Gradle?
This, for example, would let us use whatever language compiling to WASM as an implementation language for Gradle tasks. &lt;em&gt;mmmmmmm&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The result of this experience is available at &lt;a href=&quot;https://github.com/melix/gradle-wasm-plugin&quot;&gt;this repository&lt;/a&gt;.
The results are quite promising.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_isolating_task_inputs_from_the_task_execution&quot;&gt;Isolating task inputs from the task execution&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In a nutshell, a Gradle task can be seen as a function which takes a number of inputs and returns a value.
Cacheability is derived from the &quot;pureness&quot; of the function: for the same inputs, the output should be the same.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This makes it very suitable to the WebAssembly model where functions are exported to an embedder.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In reality, it&amp;#8217;s more complicated: Gradle tasks most likely use files as inputs, and also produce files.
This means that the WebAssembly runtime would need to provide I/O access for this to be really useful.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;After some support from &lt;a href=&quot;https://twitter.com/mnt_io&quot;&gt;Ivan Enderlin&lt;/a&gt;, I quickly figured out that it would be difficult to make file access work, so I simplified the problem.
In the prototype, my WASM tasks are not able to produce a file output and are limited to simply display the execution result on the console.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;For tasks which actually have files as inputs, I&amp;#8217;m reading the file contents from Java code into byte arrays which are &quot;propagated&quot; to the WASM runtime memory.
This means, effectively, that the WASM functions I played with don&amp;#8217;t have any kind of access to the file system and remain pure functions.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;With those limitations in mind, here&amp;#8217;s what I came up with.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_declaring_the_task_i_o_protocol&quot;&gt;Declaring the task I/O protocol&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Gradle is evolving fast and nowadays the idiomatic way to declare inputs and outputs of a task is to use the &lt;a href=&quot;https://docs.gradle.org/current/userguide/lazy_configuration.html&quot;&gt;lazy configuration API&lt;/a&gt;.
However, this isn&amp;#8217;t enforced and nobody prevents you from writing tasks which do not use this API.
As an implementor of a new integration mechanism, I can set the rules and actually restrict the scope to tasks which use this API, which has a number of advantages.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Say that we want to write a task which computes the sum of two integers.
With the lazy configuration API, you need two &quot;properties&quot; corresponding to the input numbers:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint java language-java&quot;&gt;&lt;code&gt;abstract class MyTask extends DefaultTask {
   abstract Property&amp;lt;Integer&amp;gt; getX(); // implementation is generated by Gradle
   abstract Property&amp;lt;Integer&amp;gt; getY();&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The actual value is &quot;lazy&quot; in the sense that it can be set via a plugin, overriden in a build script, mapped from another property, etc.
For example, that the value of the &lt;code&gt;x&lt;/code&gt; property can be computed from the output of another task:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint java language-java&quot;&gt;&lt;code&gt;x.set(myOtherTask.outputFile.map { ... }&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The advantage of this is that Gradle can track the inputs and outputs of tasks for you and that you don&amp;#8217;t have to declare any explicit dependency between tasks, making the build less brittle.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;However, once you&amp;#8217;re about to &lt;em&gt;execute&lt;/em&gt; a task, you don&amp;#8217;t really care about the &lt;code&gt;Property&amp;lt;...&amp;gt;&lt;/code&gt; wrappers anymore: what matters are the actual values, that you can &lt;code&gt;get()&lt;/code&gt;:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;int x = getX().get();
int y = getY().get();&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This often leads to some boilerplate code in task implementations.
In our case, the &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; integers are actually the only thing we care about to call our WASM function: we don&amp;#8217;t need to pass the richer &lt;code&gt;Provider&lt;/code&gt; type to the functions.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Let&amp;#8217;s imagine that we have this function written in Rust:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint rust language-rust&quot;&gt;&lt;code&gt;#[no_mangle]
pub extern fn sum(x: i32, y: i32) -&amp;gt; i32 {
    x + y
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;We can see that the inputs of this function are integers and that it returns another integer: it&amp;#8217;s that simple.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;So, what if we could actually simplify the implementation of the Gradle task itself?
With all this in mind, I decided to prototype an annotation processor which would generate the boilerplate code for me.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;To transform the Rust function above into a full Gradle task, &lt;a href=&quot;https://github.com/melix/gradle-wasm-plugin/blob/main/plugin/src/main/java/me/champeau/gradle/wasm/auto/SumIO.java&quot;&gt;all I have to write&lt;/a&gt; is a declaration of what I call its I/O protocol:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint java language-java&quot;&gt;&lt;code&gt;@WasmProtocol(
        taskName = &quot;Sum&quot;,
        classpathBinary = &quot;demo_lib&quot;,
        functionName = &quot;sum&quot;
)
public interface SumIO {
    @Input
    Property&amp;lt;Integer&amp;gt; getX();

    @Input
    Property&amp;lt;Integer&amp;gt; getY();
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This will generate a task of type &lt;code&gt;Sum&lt;/code&gt;, which will use a wasm binary found on classpath named &lt;code&gt;demo_lib&lt;/code&gt;, and use the function &lt;code&gt;sum&lt;/code&gt; from that binary as the task implementation.
That&amp;#8217;s it!&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Note that this protocol isn&amp;#8217;t declaring any output: that&amp;#8217;s a limitation of the prototype right now, which is inherently caused by this whole &quot;Gradle tasks are mostly generating files&quot; problem.
But we don&amp;#8217;t really care for now.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_a_more_realistic_example&quot;&gt;A more realistic example&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;For my tests, I used 3 different functions: this &lt;code&gt;sum&lt;/code&gt; function, a &lt;code&gt;fib&lt;/code&gt; function (the Fibonacci suite function) and I wanted to try something more complicated like computing an md5 hash.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This, for example, is how I would define the protocol for the MD5 hashing function:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint java language-java&quot;&gt;&lt;code&gt;public interface HasherIO {
    @InputFile
    @PathSensitive(PathSensitivity.NAME_ONLY)
    RegularFileProperty getInputFile();

    @OutputFile
    RegularFileProperty getOutputFile();
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Except that in this case, because the input is a file, I couldn&amp;#8217;t use my code annotation processor code generator yet (but it&amp;#8217;s planned).
Instead I wrote code to read the file manually, allocate WebAssembly memory buffers, in order to call the function which is implemented in Rust:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint rust language-rust&quot;&gt;&lt;code&gt;#[no_mangle]
pub extern fn process(bytes: *const u8, len: usize) -&amp;gt; *const c_void {
    let data: &amp;amp;[u8] = unsafe { std::slice::from_raw_parts(bytes, len) };
    let mut hasher = Md5::new();
    hasher.update(data);
    let result = hasher.finalize_fixed();
    let pointer = result
        .to_vec()
        .as_ptr();
    mem::forget(pointer);

    pointer as *const c_void
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Then all I need is to use this task in a build script. Let&amp;#8217;s see how it performs&amp;#8230;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_the_webassembly_runtimes&quot;&gt;The WebAssembly runtimes&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;I wrote 2 different implementations of the WASM integration runtime: the first one was pretty straightforward to write and makes use of &lt;a href=&quot;https://github.com/wasmerio/wasmer-java&quot;&gt;wasmer-java&lt;/a&gt;.
The second one took me significantly more time to implement and is using &lt;a href=&quot;https://www.graalvm.org/&quot;&gt;GraalVM&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Integrating &lt;a href=&quot;https://github.com/wasmerio/wasmer-java&quot;&gt;Wasmer&lt;/a&gt; was easy for different reasons:
1. it&amp;#8217;s just a library which you have to add to your classpath
2. it&amp;#8217;s relatively well documented&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;GraalVM was more complicated because:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;you actually need to run your program &lt;em&gt;on&lt;/em&gt; GraalVM&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;you need to install the WASM support separately (it&amp;#8217;s not downloadable as a regular Maven dependency, for example)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;you still need to add the GraalVM polyglot API on classpath&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;it&amp;#8217;s poorly documented at this stage (in particular, there&amp;#8217;s no documentation whatsoever on how to share memory between the Java host and the WASM guest)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Anyway, I think (but I haven&amp;#8217;t done it yet) that the GraalVM runtime will be easier to support I/O since it already offers the configuration options to let the WASM host access the host file system.
Wasmer doesn&amp;#8217;t support I/O yet.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Let&amp;#8217;s talk about performance, now.
Disclaimer: this isn&amp;#8217;t proper benchmarking. The results you will see were obtained via functional testing of a plugin. There&amp;#8217;s a lot of variance, but they were reproducible.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_measuring_the_wasmer_runtime&quot;&gt;Measuring the wasmer runtime&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In short, the wasmer runtime is very promising: it&amp;#8217;s easy to setup and actually performs extremely well.
The API is not very Java friendly, but the &lt;a href=&quot;https://github.com/melix/gradle-wasm-plugin/tree/main/wasm-invoker&quot;&gt;abstraction layer I wrote (which supports both wasmer and GraalVM)&lt;/a&gt; makes it significanly easier.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Here are some results for a memoized Fibonacci, which compares a version I wrote in Java vs the one I wrote in Rust:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Memoized Fibonacci on wasmer&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;Java fib(90) = 2880067194370816120
Took 3ms
Precompiled Rust fib(90) = 2880067194370816120
Took 366Î¼s&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The WASM version compiled from Rust is already faster than the Java version!&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Let&amp;#8217;s see how it performs when hashing a MD5 file (remember that for this use case, I&amp;#8217;m actually passing a &lt;em&gt;byte array&lt;/em&gt; to the WASM program, not a file):&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Hashing a 4MB file on wasmer&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;hash from Java is 49DFDCEF6751973A236D35401B6CBFC8
Took 64ms
hash from Rust is 49DFDCEF6751973A236D35401B6CBFC8
Took 58ms&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Again, the WASM version is still faster!&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;On both operations, the WASM binary performs better than the pure Java version. However, there&amp;#8217;s a catch: in order to reach that level of performance, the WASM binary has to be precompiled to a native binary by wasmer.
This, already takes time. If you include this in the whole picture, the numbers are different: 36ms for Fibonacci (compared to 3ms in Java, 10x slower).
However, this is in practice not a big deal since those binaries can actually be cached, meaning that if we have to call them multiple times, or from different builds, we can actually fetch them from the cache.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;All in all, it means that the wasmer runtime is very fast and integrates quite well with Java.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_measuring_the_graalvm_runtime&quot;&gt;Measuring the GraalVM runtime&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The &lt;a href=&quot;https://docs.oracle.com/en/graalvm/enterprise/20/docs/reference-manual/wasm/&quot;&gt;WebAssembly support for GraalVM&lt;/a&gt; is still experimental.
However, it has the advantage of taking advantage of the Truffle API, which promises better integration between languages and, eventually, better performance.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In my case, that wasn&amp;#8217;t quite true. Again as usual don&amp;#8217;t trust benchmarks, but here are the numbers:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Memoized Fibonacci on wasmer&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;Java fib(90) = 2880067194370816120
Took 3ms
Precompiled Rust fib(90) = 2880067194370816120
Took 21ms&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This time, the WASM code is significantly slower. The explanation is probably that contrary to the wasmer runtime, the WASM binary has to be parsed and transformed into a model that the Truffle API can understand, and as far as I could tell, this is not cacheable. However, this isn&amp;#8217;t the only explanation, as we can see with the hash example:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Hashing a 4MB file on GraalVM&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;hash from Java is 49DFDCEF6751973A236D35401B6CBFC8
Took 57ms
hash from Rust is 49DFDCEF6751973A236D35401B6CBFC8
Took 407ms&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Again we can see that the performance is significantly worse with GraalVM.
I must again say that maybe I&amp;#8217;m not using the API properly.
In particular, I have found no better way to pass the &lt;code&gt;byte[]&lt;/code&gt; to the WASM memory model other than &lt;a href=&quot;https://github.com/melix/gradle-wasm-plugin/blob/main/wasm-invoker/src/main/java/me/champeau/wasm/invocation/internal/GraalVMInvoker.java#L99-L103&quot;&gt;byte by byte!&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_what_we_ve_learnt&quot;&gt;What we&amp;#8217;ve learnt&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In this blog post, we&amp;#8217;ve seen that we can use a wasm binary in Gradle as the implementation of a task.
This binary can be written in any language which supports compiling to WebAssembly.
In my [test project], I have written tasks in 2 different languages: &lt;a href=&quot;https://www.rust-lang.org/&quot;&gt;Rust&lt;/a&gt; and &lt;a href=&quot;https://github.com/AssemblyScript/assemblyscript&quot;&gt;AssemblyScript&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;We&amp;#8217;ve seen that we can integrate WASM binaries using 2 different &quot;runtimes&quot;:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/wasmerio/wasmer-java&quot;&gt;Wasmer&lt;/a&gt;, which is using JNI and compiles, as far as I understand, WebAssembly binaries to native code&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.graalvm.org/&quot;&gt;GraalVM&lt;/a&gt;, which is a different Java Virtual Machine, which usually performs extremely well with Java, and provides a &lt;a href=&quot;https://www.graalvm.org/reference-manual/polyglot-programming/&quot;&gt;Polyglot runtime&lt;/a&gt; leveraging the &lt;a href=&quot;https://www.graalvm.org/graalvm-as-a-platform/language-implementation-framework/&quot;&gt;Truffle API&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;As of today, the Wasmer version performs significantly better and WASM functions can be executed even faster than Java code!
The GraalVM version is still experimental and performs quite poorly compared to using native Java code. It&amp;#8217;s also more painful to test because it&amp;#8217;s not enough to install GraalVM: you also have to install components separately, which is not build friendly, nor CI friendly.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The next step for me is to try to integrate more directly with the file system: at the current stage, none of the approaches is suitable for Gradle as we need to read and write files.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Also, one has to keep in mind that it&amp;#8217;s pretty rare that you&amp;#8217;d like to integrate in a build arbitrary code like this: in general, you want to call external tools (&lt;code&gt;javac&lt;/code&gt;, &lt;code&gt;gcc&lt;/code&gt;, &amp;#8230;).
Nevertheless, this experiment is quite fun and I&amp;#8217;m going to experiment more with this annotation processing API, which, I think, would be valuable in any case.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>The problem with Gradle: really?</title>
      <link>https://melix.github.io/blog/2021/01/the-problem-with-gradle.html</link>
      <pubDate>Wed, 6 Jan 2021 00:00:00 +0100</pubDate>
      <guid isPermaLink="false">2021/01/the-problem-with-gradle.html</guid>
      	<description>
	&lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Disclaimer: I&amp;#8217;m a former Groovy committer and a Gradle Inc. employee.
However, I started using Gradle long before I joined Gradle, and I have quite some experience with Java build tools: I started with Ant, but I also used Maven quite a lot, then fell in love with Gradle, for many reasons.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://www.bruceeckel.com/2021/01/02/the-problem-with-gradle/&quot;&gt;A blog post from Bruce Eckel&lt;/a&gt; made quite some noise on Reddit (no wonder, Bruce is a guru!).
It&amp;#8217;s not the first time I read comments about Gradle, this article in itself is balanced and not that negative.
Most of the criticism is on the title itself, which is misleading and looks like a clickbait.
One can easily be retweeted without actually reading the details, and most importantly the conclusion.
Also, it doesn&amp;#8217;t compare with what you&amp;#8217;d have to do with &lt;em&gt;other&lt;/em&gt; build tools, which is important to draw good conclusions.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_what_makes_gradle_different&quot;&gt;What makes Gradle different?&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;At the core of this blog post is the thing that the &quot;big picture&quot; of Gradle is unclear.
There are several things to say here.
First of all, Gradle is not a new, shiny toy to play with: it was born more than 10 years ago, and saw its v1.0 release on Jun 12, 2012.
Second, there&amp;#8217;s not a &quot;single&quot; problem with Gradle: there are different problems, some more important than the others, but there are also many, many benefits.
As such, one should draw a complete picture, which is sometimes hard for build tools, something that developers tend to underestimate, in particular in terms of impact on developer productivity.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Gradle is designed to improve developer productivity which is achieved via incremental builds, incremental tasks, parallel execution, reproducibility and many other features.
Let&amp;#8217;s put it this way: if you look at Gradle from the DSL point of view, that is, the look and feel, instead of its capabilities, the engine, you will miss the most interesting parts.
The beauty of Gradle is not in its &quot;flexibility&quot; offered because it uses configuration as code: it&amp;#8217;s the engine which is designed to model software properly and optimizes building software.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_do_you_have_to_know_everything&quot;&gt;Do you have to know everything?&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Bruce states that with Gradle, &quot;To do anything you have to know everything&quot;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;While the formula is elegant, this is a bold statement: this simply doesn&amp;#8217;t align with the reality of the Gradle ecosystem, our community and larger user base.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;What is true, however, is that the learning curve of Gradle is higher than with other build tools (say, Maven for example).
I always said that the learning curve of Gradle is difficult, but once you get it, the benefit is just amazing: we have customers who tell stories about dramatic productivity boosts after migrating to Gradle, simplified maintenance and coordination of large development teams via corporate plugins.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;One of the reasons is that Gradle is fundamentally different from other build tools: it focuses on modeling software components and their relationships, and as such it can be considered as a language for building &lt;em&gt;any&lt;/em&gt; kind of application. It raises the concept of convention over configuration to another level.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;That&amp;#8217;s no surprise that Gradle has been successfully used to build software in various ecosystems: the JVM, where it&amp;#8217;s born (with Java, Groovy, Scala in particular), but also native development (take a look at &lt;a href=&quot;https://nokee.dev/&quot;&gt;Nokee&lt;/a&gt; if you are interested), Go (&lt;a href=&quot;https://github.com/gogradle/gogradle&quot;&gt;Go Gradle&lt;/a&gt;), &amp;#8230;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Some ecosystems actually build on top of unique features of Gradle, in particular in terms of dependency management: Android (with multiple flavors of libraries and applications) or Kotlin in particular (with Kotlin Multiplatform).&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Why is that? Gradle is an execution engine optimized for build workflows, with intelligence about how to build things incrementally.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Nonetheless, improving the experience of first time users is something the Gradle team focuses on, as we will see below.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_tasks_vs_dependencies_a_simplistic_view&quot;&gt;Tasks vs dependencies: a simplistic view&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Bruce says that any build system is basically the combination of two essential ingredients: &lt;em&gt;tasks&lt;/em&gt; and &lt;em&gt;dependencies&lt;/em&gt;, where dependencies are seen as artifacts.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;That is not quite correct in case for Gradle: Gradle is responsible for wiring units of work together, either through explicit or implicit dependencies.
It&amp;#8217;s important to understand that &quot;dependency&quot; here has a wider meaning: it&amp;#8217;s something which is required to be able to execute a unit of work.
There is, technically speaking, no difference between an external and an internal dependency. What matters is that we have units of work, which have inputs and outputs.
The role of Gradle is to wire things so that everything is ordered properly and optimized for execution (parallelism, caching, &amp;#8230;).
It&amp;#8217;s a mistake to think that there are only tasks and dependencies (files, mostly): there are work units, inputs and outputs.
A task (say, &lt;code&gt;JavaCompile&lt;/code&gt;) is just &lt;em&gt;one kind&lt;/em&gt; of work unit, but that&amp;#8217;s not the only one. Here are some other kind of work units: transforming artifacts (for example, transform a &lt;em&gt;jar&lt;/em&gt; into something else before it is consumed), downloading a toolchain, uploading an artifact to the build cache, &amp;#8230; A task itself can be splitted into several work units in order to maximize incrementality and parallelism.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;A lot of the criticism we see on Gradle is because there&amp;#8217;s a mismatch between the mental model of what Gradle is, and the surface, which is the language(s) it uses to configure the actual model.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;A lot of the confusion comes from the fact that while Gradle has a vision, it should be better shared and explained.
It&amp;#8217;s also victim of its age which means success: the road towards fine grained execution, safe parallelism, configuration, &amp;#8230; is hard and there are some APIs which are sub-optimal for this, and &lt;a href=&quot;https://docs.google.com/forms/d/e/1FAIpQLSc9aQrjjsxVqXDkYR35ExeiI1yEIksRXVtN6asuaem084l3aA/viewform&quot;&gt;maintaining backwards compatibility is a day-to-day challenge&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Let&amp;#8217;s explain a bit what Gradle has to do, when you say that you want to execute a &lt;em&gt;task&lt;/em&gt;:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;configure the task (execute its &lt;em&gt;configuration phase&lt;/em&gt;), which means executing plugins which configure the default values, use your configuration, etc.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;compute the &lt;em&gt;dependencies&lt;/em&gt; of the task, which can either be explicit (typically the &lt;code&gt;dependsOn&lt;/code&gt; clause) or &lt;em&gt;implicit&lt;/em&gt; (because you configured a task input as the output of another task, typically): this is basically a directed graph resolution engine, which is very fine grained and where each node is a unit of work.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;and finally executes the nodes of the graph in an optimized way&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Historically, Gradle has separated the &lt;em&gt;configuration phase&lt;/em&gt; from the &lt;em&gt;execution phase&lt;/em&gt;, but it doesn&amp;#8217;t have to be that way: as soon as the inputs of a task are ready, we should be able to execute it, and we shouldn&amp;#8217;t have to wait for the configuration of other tasks to be ready to do it.
Also Gradle made it easy, in the beginning, to &lt;em&gt;inline&lt;/em&gt; the definition of tasks, including their execution phase, in a build script, but it is, for quite some time, considered a bad design principle: don&amp;#8217;t write &lt;em&gt;build logic&lt;/em&gt; in build scripts. The whole blog post from Bruce never mentions this term a single time: &lt;a href=&quot;https://docs.gradle.org/current/userguide/custom_plugins.html&quot;&gt;write plugins&lt;/a&gt;!&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Despite our efforts, lots of resources on the web still focus on how to declare tasks, how flexible Gradle is, without taking time to leverage good engineering practices. In Java nobody writes a giant single class with all the logic &lt;em&gt;and&lt;/em&gt; the data as code, right? So don&amp;#8217;t do it in your build, that&amp;#8217;s as simple as that.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Let&amp;#8217;s be honest: it&amp;#8217;s partly our fault, and for that I agree with Bruce: the documentation of Gradle is huge and things can be made better, especially for beginners.
It&amp;#8217;s also true that the docs contain &lt;em&gt;outdated patterns&lt;/em&gt; and it&amp;#8217;s often very difficult to realize that you have outdated info in thousands of pages of docs.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;There is, however, a good amount of resources for beginners:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;samples: &lt;a href=&quot;https://docs.gradle.org/current/samples/index.html&quot;&gt;https://docs.gradle.org/current/samples/index.html&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;guides (slowly replaced with the samples above): &lt;a href=&quot;https://gradle.org/guides/&quot;&gt;https://gradle.org/guides/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;free trainings: &lt;a href=&quot;https://gradle.com/training/&quot;&gt;https://gradle.com/training/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;webcasts: &lt;a href=&quot;https://gradle.com/blog/tag/webcast/&quot;&gt;https://gradle.com/blog/tag/webcast/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_deconstructing_the_myth&quot;&gt;Deconstructing the myth&lt;/h3&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;We are still in the early days of the âadding a build system atop an existing languageâ paradigm. Gradle is an experiment in this paradigm, so we expect some sub-optimal choices. However, by understanding its issues you might have less frustration learning Gradle than I did.&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;attribution&quot;&gt;
&lt;cite&gt;The Problem With Gradle&lt;/cite&gt;&lt;br&gt;
&amp;#8212; Bruce Eckel
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This is incorrect. Thinking that Gradle is just about calling methods is the wrong mental model. Thinking that Gradle is &quot;programming a build&quot; is wrong. Gradle uses a programming language as a foundation for &quot;configuration as code&quot;, but it is &lt;em&gt;really&lt;/em&gt; about configuration, not &lt;em&gt;programming&lt;/em&gt;. Surely a programming language is interesting to use in the &quot;configuration as code&quot; paradigm, but focusing on that aspect and assuming that it works as a general purpose language is wrong and will inevitably lead to confusion.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Gradle is also &lt;em&gt;not&lt;/em&gt; an experiment: it&amp;#8217;s the most advanced tool you can find in this area, and it works &lt;em&gt;because&lt;/em&gt; the language builds on top of an engine which is made to execute workflows.
A number of build tools, including modern ones, are only fast because they put the maintenance and optimization burden on the build author: declare everything, re-generate build scripts, etc.
We, in the Gradle team, think that we can be more correct, more performant &lt;em&gt;without&lt;/em&gt; having to compromise on user experience.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;We even had teams challenging us on performance with modern tools like Bazel, and we proved that with unique features like &lt;a href=&quot;https://docs.gradle.org/current/userguide/configuration_cache.html#header&quot;&gt;configuration caching&lt;/a&gt;, Gradle was able to outperform it in almost all scenarios: you get the benefit of terse, maintainable scripts, with performance. win-win.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;At this stage, it&amp;#8217;s time to deconstruct some misconceptions of the blog post, because as long as this message is propagated, we will not achieve what should be the focus of our industry: safer, faster, reproducible builds for everyone.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_1_you_re_not_configuring_you_re_programming&quot;&gt;1. You&amp;#8217;re not Configuring, Youâre Programming&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;You should see &lt;em&gt;Gradle build scripts&lt;/em&gt; as &lt;em&gt;configuration scripts&lt;/em&gt;, which actually configure a &lt;em&gt;model&lt;/em&gt;.
The surface is a DSL, a language, but what you do, what you &lt;em&gt;should do&lt;/em&gt;, is to declaratively model your software.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;For example, this Groovy script:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;plugins {
   id &apos;java-library&apos;
}

dependencies {
    api &apos;org.springframework:spring-core:2.5.6&apos;
    implementation &apos;org.apache.commons:commons-lang3:3.3.10&apos;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Is a build script which configures a library written in Java, while this build script, written in Kotlin, configures a different kind of software component:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint kotlin language-kotlin&quot;&gt;&lt;code&gt;plugins {
    id(&quot;org.gradle.presentation.asciidoctor&quot;)
}

presentation {
    githubUserName.set(&quot;melix&quot;)
    githubRepoName.set(&quot;gradle-6-whats-new&quot;)
    useAsciidoctorDiagram()
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;which is actually a &lt;code&gt;reveal.js&lt;/code&gt; slide deck, built with Gradle! This is the &lt;em&gt;full&lt;/em&gt; build script for this, and it&amp;#8217;s extremely important to realize that: the &quot;code&quot; that you get shouldn&amp;#8217;t have any custom tasks, in particular: all of the complexity, which is nothing more than the &quot;model&quot;, is hidden in a &lt;em&gt;plugin&lt;/em&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;I strongly encourage you to read my &lt;a href=&quot;https://melix.github.io/blog/2019/11/gradle-scripting.html&quot;&gt;Gradle myth busting: scripting&lt;/a&gt; blog post which describes exactly that.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In addition, you can watch this 10 minute video I made about writing idiomatic build scripts:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;
&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/MaansFoPHKg&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen&gt;&lt;/iframe&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;What it means is that while Gradle build scripts are &lt;em&gt;executed&lt;/em&gt;, this is code which &lt;em&gt;configures the model&lt;/em&gt;, so you&amp;#8217;re &quot;programming the configuration&quot;, if you will.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_2_groovy_is_not_java&quot;&gt;2. Groovy is Not Java&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;There&amp;#8217;s not much to say here, because it barely has anything to do with Gradle.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;You will notice that when I showed build scripts above, I showed a &lt;em&gt;Groovy&lt;/em&gt; build script and a &lt;em&gt;Kotlin&lt;/em&gt; one. It&amp;#8217;s important to notice that Gradle allows both, because under the hood, it&amp;#8217;s an API.
As I said, Gradle provides a foundation for building software components, a dependency resolution engine, an execution engine.
&lt;em&gt;Plugins&lt;/em&gt; are at the core of the system and are responsible for building &lt;em&gt;models&lt;/em&gt; of software we build: a Java library is different from an Android application, so there&amp;#8217;s &lt;em&gt;no reason&lt;/em&gt; to have the same source layout, for example.
The fact that Gradle uses Groovy as a language to do its configuration is an &lt;em&gt;implementation detail&lt;/em&gt;.
I think it&amp;#8217;s a mistake to consider that you need a programming language to do what Gradle does: it helps, and lots of people actually appreciate Gradle&amp;#8217;s flexibility in that regard, but it&amp;#8217;s not what you should focus on.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Both Groovy and Kotlin have pros and cons. If you use Intellij IDEA, for example, the Kotlin DSL has very good arguments and makes this model completely visible: completion is available, you don&amp;#8217;t have to &quot;guess&quot; what to type: depending on the plugins you apply, you get the configuration blocks you need, and nothing more!&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;To come back to this section, a common misconception is that Gradle is written in Groovy. It&amp;#8217;s not. Gradle is written in Java, mostly. There&amp;#8217;s a lot of Groovy code in Gradle for testing (we use Spock, in particular), but we also have Kotlin code. The build scripts, however, use Groovy or Kotlin.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The DSL design definitely was influenced by Groovy, though, that&amp;#8217;s very true.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_3_gradle_uses_a_domain_specific_language&quot;&gt;3. Gradle Uses a Domain-Specific Language&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Yes it does. I should say it&amp;#8217;s an &quot;extensible&quot; DSL. But when I&amp;#8217;m reading this:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;How helpful is this DSL syntax, really? I have to translate it into function calls in my head when I read it. So for me itâs additional cognitive overhead which is ultimately a hindrance. The DSL operations can all be done with function calls, and programmers already understand function calls.&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;I&amp;#8217;m thinking that this is again seeing the problem from the wrong angle. You should &lt;em&gt;not&lt;/em&gt; see this as function calls, or code being executed. You should see this as a model being configured. You can&amp;#8217;t, actually, assume &lt;em&gt;when&lt;/em&gt; this code is going to be called (because, we have configuration avoidance, for example). So a DSL is really what it means: it&amp;#8217;s a language meant to configure the model, nothing more. By trying to interpret &lt;em&gt;how&lt;/em&gt; Gradle does this, you&amp;#8217;re actually distracted from what matters: what are you trying to build?&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_4_there_are_many_ways_to_do_the_same_thing&quot;&gt;4. There are Many Ways to do the Same Thing&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This one is one of my favourites. I always read &quot;there are too many ways to do the same thing&quot;. Sure there are. Just like in Java, can you tell me how many ways you can write a loop? Let&amp;#8217;s see&amp;#8230;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;indexed loop&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;for (int i=0; i&amp;lt;items.length(); i++) {
   ...
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;foreach loop&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;for (String item: items) {
...
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;while loop&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;Iterator&amp;lt;String&amp;gt; it = items.iterator();
while (it.hasNext()) {
  ...
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;(not mentioning the &lt;code&gt;do...while&lt;/code&gt; variant)&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;streams&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;items.stream()
   .map(...)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;streams again&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;items.forEach(...)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Does anyone complain that Java has too many ways to do the same thing? Certainly not, because there are different reasons: historical (good old loops came first), performance (sometimes streams are not that fast), semantic (iterator lets you delete things while iterating), &amp;#8230; Even Python has many ways to do the same thing. Isn&amp;#8217;t it the case when you&amp;#8217;re free to write code? Some consider it&amp;#8217;s a reason alone &lt;em&gt;not to use Gradle&lt;/em&gt;. It would be a mistake, because you don&amp;#8217;t stop programming Java because it has too many ways to write a loop.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The thing is &quot;use the right tool for the right job&quot;. Gradle is no different. Except that there are not so many ways to do things ð Some are legacy patterns, and there we need to do better at documenting, some are just because people are trying to write code in their build scripts when &lt;em&gt;they shouldn&amp;#8217;t&lt;/em&gt; (write plugins!).&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;I should mention that we started something called the &lt;strong&gt;idiomatic Gradle&lt;/strong&gt; project for these excellent reasons.
The goal is to encourage best practices, document the most idiomatic way to do something, covering multiple use cases and their differences.
There will be a blog post from the team about this project, in the meantime you can already read some results:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;a sample showing how to build &lt;a href=&quot;https://docs.gradle.org/current/samples/sample_building_java_applications_multi_project.html&quot;&gt;multi-project Java applications&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;documentation about &lt;a href=&quot;https://docs.gradle.org/6.8-rc-5/userguide/structuring_software_products.html&quot;&gt;structuring larger builds&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;a &lt;a href=&quot;https://jjohannes.github.io/joker-conf-2020/#/&quot;&gt;presentation&lt;/a&gt; from my colleague Jendrik Johannes about idiomatic Gradle at JokerConf&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Last but not least, we have ongoing conversations about a &quot;strict mode&quot; in Gradle to actually enforce some language constructs, or even a different DSL, to limit what you can actually do in a build script.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_5_magic&quot;&gt;5. Magic&lt;/h4&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Any sufficiently advanced technology is indistinguishable from magic.&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;attribution&quot;&gt;
&lt;cite&gt;Profiles of the Future: An Inquiry Into the Limits of the Possible&lt;/cite&gt;&lt;br&gt;
&amp;#8212; Arthur C. Clarke
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This whole section is basically about understanding the separation between &lt;em&gt;configuration&lt;/em&gt; and &lt;em&gt;execution&lt;/em&gt; phases, but really what bothers me most is that it&amp;#8217;s much easier to grasp if you just &lt;em&gt;don&amp;#8217;t write inline tasks into build scripts&lt;/em&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;For example, if I write, in a plugin:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint java language-java&quot;&gt;&lt;code&gt;public abstract class ProcessTemplates extends DefaultTask {

    @Input
    public abstract Property&amp;lt;TemplateEngineType&amp;gt; getTemplateEngine();

    @InputFiles
    public abstract ConfigurableFileCollection getSourceFiles();

    @OutputDirectory
    public abstract DirectoryProperty getOutputDir();

    @TaskAction
    void execute() { ... }&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;then the separation between &lt;em&gt;inputs&lt;/em&gt; (properties annotated with &lt;code&gt;@InputXXX&lt;/code&gt;), outputs &lt;code&gt;@OutputDirectory&lt;/code&gt; and the actual task execution &lt;code&gt;@TaskAction&lt;/code&gt; is obvious.
More importantly, if you do this Gradle helps you by providing you guidance on what annotations to use, how to make it compatible with caching, etc for free (via embedded linting).&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;I repeat, nobody should every inline &lt;em&gt;build logic&lt;/em&gt; in a build script. Nobody.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Accidentally, the scripts Bruce shows in this section are using Groovy, which, for backwards compatibility reasons, uses &lt;em&gt;eager configuration APIs&lt;/em&gt;.
If you use Kotlin scripts, all the task creation, registration, is done lazily, avoiding unnecessary configuration. You can do this in Groovy too, if you use the &lt;a href=&quot;https://docs.gradle.org/current/userguide/task_configuration_avoidance.html&quot;&gt;configuration avoidance APIs&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_5bis_the_lifecyle&quot;&gt;5bis, the lifecyle&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This section again discusses &lt;em&gt;configuration&lt;/em&gt; vs &lt;em&gt;execution&lt;/em&gt;. Just a terminology comment here: a &lt;em&gt;lifecyle&lt;/em&gt; in Gradle and other build tools is a different thing. See my other &lt;a href=&quot;https://melix.github.io/blog/2018/09/gradle-lifecycle.html&quot;&gt;Gradle myth busting: lifecyle&lt;/a&gt; blog post for reference.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_other_issues&quot;&gt;Other Issues&lt;/h4&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The Gradle documentation assumes you already know a lot.&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Yes, and no. The Gradle documentation is large and as I said in the intro, we do have sections for beginners. What is true, and I&amp;#8217;m quite mad about this, is that our docs layout is terrible, and that good documentation is very difficult to find out.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;We also started to rewrite sections so that they are &lt;em&gt;use case centered&lt;/em&gt;, see the &lt;a href=&quot;https://docs.gradle.org/current/userguide/dependency_management.html&quot;&gt;dependency management&lt;/a&gt; docs for example.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Slow startup times&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In most cases, &quot;slow startup times&quot; actually refer to &quot;slow configuration times&quot;. This is in general because of too much code being executed at configuration time. That&amp;#8217;s why we have &lt;a href=&quot;https://docs.gradle.org/current/userguide/task_configuration_avoidance.html&quot;&gt;configuration avoidance APIs&lt;/a&gt; and that you can possibly use &lt;a href=&quot;https://scans.gradle.com&quot;&gt;build scans&lt;/a&gt; which tell you that you are doing too much at configuration time.
However, with the experimental &lt;a href=&quot;https://docs.gradle.org/current/userguide/configuration_cache.html&quot;&gt;configuration cache&lt;/a&gt;, those configuration time issues should soon be a thing of the past.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Be careful with some (very) popular plugins: some plugin authors just don&amp;#8217;t realize that the way they configure builds, reach to other projects or perform cross-configuration has a significant impact on build performance, and therefore user experience.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;All that said, we&amp;#8217;re doing even more: I mentioned the &lt;a href=&quot;https://docs.gradle.org/current/userguide/configuration_cache.html&quot;&gt;configuration cache&lt;/a&gt; earlier. This is still work in progress, but we have amazing results with this. Very large multi-project builds are configured very quickly. We&amp;#8217;re working with customers and the Android team on this.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Itâs not that easy to discover Gradleâs abilities, and there are so many abilities that you often donât know whatâs possible&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Oh yes. Oh, yes. Gradle is probably the most advanced build tool of the market. It has dozens of features, including unique features you don&amp;#8217;t find in any other build tool. They are hardly discoverable. We need more advocacy on those, and make them more visible. I am not sure how we can do this, honestly.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_now_that_i_get_it&quot;&gt;Now That I Get It&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The conclusion of the blog post is quite positive. However it mentions IDE support. I should say, despite being a Groovy developer, I use it everyday, that if you use IntelliJ IDEA in particular, discovering Gradle using the Kotlin DSL is &lt;em&gt;much&lt;/em&gt; easier. You get smart, contextual, IDE completion, which really helps in understanding how Gradle works. There are drawbacks in using Kotlin build scripts, in particular because Kotlin compilation is painfully slow (Scala developers would understand). Independently of the JetBrains team, which is working on performance of the compiler, &lt;a href=&quot;https://docs.gradle.org/6.8-rc-5/release-notes.html#kotlin-dsl-performance&quot;&gt;Gradle 6.8 will also provide some nice Kotlin DSL performance improvements&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_conclusion&quot;&gt;Conclusion&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In this blog post I have commented on some remaining misconceptions about Gradle, which are still visible in Bruce&amp;#8217;s blog post. However, there&amp;#8217;s no blocker there. I would however really encourage you to go the idiomatic Gradle route and try to follow modern Gradle design principles. If you have time, here&amp;#8217;s a talk I gave recently at the Madrid Groovy User Group about modernizing the Groovy build, I think it summarizes quite a lot why a number of the patterns described in Bruce&amp;#8217;s blog post are outdated and shouldn&amp;#8217;t be promoted:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;
&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/HXAV9pL5Rf8&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen&gt;&lt;/iframe&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
	</description>
    </item>

  </channel> 
</rss>
