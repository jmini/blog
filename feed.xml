<?xml version="1.0"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>CÃ©dric Champeau's blog</title>
    <link>https://melix.github.io/blog/</link>
    <atom:link href="https://melix.github.io/blog//feed.xml" rel="self" type="application/rss+xml" />
    <description>JBake Bootstrap Template</description>
    <language>en-gb</language>
    <pubDate>Thu, 4 Nov 2021 19:23:23 +0100</pubDate>
    <lastBuildDate>Thu, 4 Nov 2021 19:23:23 +0100</lastBuildDate>

    <item>
      <title>Multi-repository development made easy</title>
      <link>https://melix.github.io/blog/2021/11/multirepo-dev-made-easy.html</link>
      <pubDate>Thu, 4 Nov 2021 00:00:00 +0100</pubDate>
      <guid isPermaLink="false">2021/11/multirepo-dev-made-easy.html</guid>
      	<description>
	&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_are_you_working_in_a_multi_repository_setup&quot;&gt;Are you working in a multi-repository setup?&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In general, things start getting messy as soon as you have a feature which requires changes to more than one repository.
For example, you may have a &lt;code&gt;core&lt;/code&gt; repository, and a &lt;code&gt;module&lt;/code&gt; repository, and the feature that you&amp;#8217;re working on for &lt;code&gt;module&lt;/code&gt; requires API changes in &lt;code&gt;module&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;If so, it&amp;#8217;s likely that you&amp;#8217;ve been annoyed by the fact that to be able to test the changes to &lt;code&gt;module&lt;/code&gt;, you minimally had to publish a local snapshot to your local Maven repository.
While this can kind of work locally, it&amp;#8217;s easy to miss publishing from time to time, and therefore thinking that a change works when it actually relies on an outdated dependency.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Things get more complicated as soon as CI is involved, or that you want to share the results of work in progress, for example for review, with your colleagues:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;did you ever had to explain that they had to checkout &lt;code&gt;core/some-branch&lt;/code&gt;, publish to Maven local, then checkout &lt;code&gt;module/some-feature-branch&lt;/code&gt; and test it?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;did you ever realize late that you forgot to push changes to &lt;code&gt;master&lt;/code&gt; so that they could try?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;did you ever complain that to make this happen on CI, you actually had to &lt;em&gt;eagerly merge&lt;/em&gt; your feature branch to &lt;code&gt;core&lt;/code&gt;, just so that the other repository, on a &lt;em&gt;feature branch&lt;/em&gt;, could see it?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;did you ever want to see if your modules simply do not break with latest &lt;em&gt;master&lt;/em&gt;, without having to change anything to your build scripts?&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;If you answered yes to any of those questions, then I&amp;#8217;m glad to say &lt;strong&gt;there&amp;#8217;s a solution!&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The underlying problem is that using Maven SNAPSHOTs to deal with multi-repository development is not a good enough.
It cannot model the complexity of multi-repository development, with features being developed concurrently on different branches.
Using SNAPSHOTs (binary dependencies) to coordinate projects leads to hard to diagnose bugs, broken integration processes.
You typically have to eagerly push changes, or wait for snapshots to be published on a shared repository, just so that you can actually verify that integration with other modules work.
Those problems do not happen in a a &lt;em&gt;single repository&lt;/em&gt; world, because all changes are integrated at once.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;I faced this very same problem with Micronaut:I&amp;#8217;m currently working on a feature which involves changes to multiple repositories at once:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/micronaut-projects/micronaut-core/&quot;&gt;Micronaut Core&lt;/a&gt;, with additional public APIs&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/micronaut-projects/micronaut-aot/&quot;&gt;Micronaut AOT&lt;/a&gt;, the new module I&amp;#8217;m actively working on&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/micronaut-projects/micronaut-gradle-plugin/&quot;&gt;the Micronaut Gradle Plugin&lt;/a&gt;, which integrates the AOT module&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;and a local test project which uses the modified Gradle plugin&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;That&amp;#8217;s, minimally 4 different projects, and a change to any of them is a pain to deal with.
With my experience with Gradle, I &lt;em&gt;knew&lt;/em&gt; there was a better way.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_a_plugin_to_make_it_easier&quot;&gt;A plugin to make it easier!&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Today, I&amp;#8217;m happy to announce a new Gradle plugin which aims at making multi-repository development a breeze: &lt;a href=&quot;https://melix.github.io/includegit-gradle-plugin&quot;&gt;Included Git repositories plugin&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This plugin lets you &lt;em&gt;import Git repositories&lt;/em&gt; as source dependencies, without having to change your dependency declarations.
What does that mean?
In the example above, it means that I can explain, when I&amp;#8217;m working on &lt;code&gt;module&lt;/code&gt;, that it needs to build against &lt;code&gt;core/some-branch&lt;/code&gt;: Gradle will then automatically checkout the project, build the branch and &lt;em&gt;substitute&lt;/em&gt; any binary dependency corresponding to &lt;code&gt;core&lt;/code&gt; with the source dependency.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In a nutshell, the configuration would look like this:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;gitRepositories {
	include(&apos;core&apos;) {
		uri = &apos;git@github.com:mycompany/core.git&apos;
		branch = &apos;some-branch&apos;
	}
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;That&amp;#8217;s it! No need to change your build scripts to update dependency coordinates, Gradle will do the magic!&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;It completely changes the way of thinking about multi-repository development, because CI, or colleagues, would not have to care about instructions about how to build your particular branch: everything is known upfront.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Of course, you&amp;#8217;re going to tell that well, that&amp;#8217;s cool but it still requires you to push your changes to the remote repository so that you can test things &lt;em&gt;locally&lt;/em&gt;.
Well, a good multi-repository development story must integrate both the &lt;em&gt;local&lt;/em&gt; and &lt;em&gt;remote&lt;/em&gt; experience.
This is why this plugin actually makes it a breeze to support this pattern.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;There are actually 2 ways you can handle this.
The first one is to explain to Gradle that instead of checking out the sources, it can simply use a local copy instead.
In this case, the plugin will simply &lt;em&gt;ignore&lt;/em&gt; whatever you declared in the &lt;code&gt;gitRepositories&lt;/code&gt; block for the repository, and use whatever is available locally.
For this you&amp;#8217;d set a &lt;code&gt;local.git.&amp;lt;repoName&amp;gt;&lt;/code&gt; Gradle property (in your &lt;code&gt;gradle.properties&lt;/code&gt; file) pointing to your local copy.
In the example above, I would for example add a &lt;code&gt;local.git.core&lt;/code&gt; property pointing to my local copy of &lt;code&gt;core&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Alternatively, if you keep things organized into checkout directories like I do, it&amp;#8217;s likely that you have all your &lt;code&gt;micronaut&lt;/code&gt; related projects in a single &lt;code&gt;micronaut-projects&lt;/code&gt; directory.
In this case, by setting the &lt;code&gt;auto.include.git.dirs&lt;/code&gt; Gradle property to the &lt;code&gt;micronaut-projects&lt;/code&gt; directory, the plugin will automatically map directory names in that &lt;code&gt;micronaut-projects&lt;/code&gt; directory to included Git repository names.
So if I have:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;gitRepositories {
	include(&apos;micronaut-core&apos;) {
		uri = &apos;git@github.com:mycompany/core.git&apos;
		branch = &apos;some-branch&apos;
	}
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;and a &lt;code&gt;micronaut-core&lt;/code&gt; directory under &lt;code&gt;micronaut-projects&lt;/code&gt;, then it will automatically be used instead of cloned from remote.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Those options make it extremely convenient to develop locally, and only push changes when ready.
On CI, builds would checkout the dependents automatically, and you&amp;#8217;d have nothing to configure.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_more_complex_use_cases&quot;&gt;More complex use cases&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The very same mechanism can be used to create &quot;integration&quot; builds on CI.
For example, it makes it very simple to have builds which would automatically build against the latest state of &lt;code&gt;master&lt;/code&gt;, instead of having to wait for &lt;code&gt;SNAPSHOT&lt;/code&gt; to be published, and more importantly, without having to change any build file.
As a bonus, it also works for &lt;em&gt;transitive dependencies&lt;/em&gt;: for example if you have A --depends on-&amp;#8594; B --depends on-&amp;#8594; C, then you may want to make sure that if &lt;code&gt;C&lt;/code&gt; is changed, &lt;code&gt;A&lt;/code&gt; still works. How do you do this with snapshots, if there&amp;#8217;s no direct dependency between &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt;? This plugin makes it very simple to test: just declare a Git repository for C and you&amp;#8217;re done!&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_need_your_help&quot;&gt;Need your help!&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;I think this plugin has potential to dramatically change how we develop in the multi-repository world.
The plugin is in very early stages, and I will need your help: report bugs, improve the documentation, improve testing, etc.
It will also be interesting to get your user stories so that we, collectively, can improve it to support more scenarios.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Plugin documentation: &lt;a href=&quot;https://melix.github.io/includegit-gradle-plugin&quot;&gt;https://melix.github.io/includegit-gradle-plugin&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Plugin development home: &lt;a href=&quot;https://github.com/melix/includegit-gradle-plugin&quot;&gt;https://github.com/melix/includegit-gradle-plugin&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Plugin on Gradle plugin portal: &lt;a href=&quot;https://plugins.gradle.org/plugin/me.champeau.includegit&quot;&gt;https://plugins.gradle.org/plugin/me.champeau.includegit&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>A Gradle quickie: properly using dependsOn</title>
      <link>https://melix.github.io/blog/2021/10/gradle-quickie-dependson.html</link>
      <pubDate>Wed, 6 Oct 2021 00:00:00 +0200</pubDate>
      <guid isPermaLink="false">2021/10/gradle-quickie-dependson.html</guid>
      	<description>
	&lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Today I&amp;#8217;d like to share a small example of what &lt;em&gt;not to do&lt;/em&gt; with Gradle.
Some of you may already know that I recently joined the &lt;a href=&quot;https://micronaut.io/&quot;&gt;Micronaut team at Oracle&lt;/a&gt;, and part of my job is to improve the build experience, be it for Micronaut itself or Micronaut users.
Today I&amp;#8217;m going to focus on an example I found in the Micronaut build itself.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;strong&gt;TL/DR&lt;/strong&gt;: If you use &lt;code&gt;dependsOn&lt;/code&gt;, you&amp;#8217;re likely doing it wrong.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_when_should_you_use_dependson&quot;&gt;When should you use dependsOn?&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In a nutshell, Gradle works by computing a graph of task dependencies.
Say that you want to build a JAR file: you&amp;#8217;re going to call the &lt;code&gt;jar&lt;/code&gt; task, and Gradle is going to determine that to build the jar, it needs to compile the classes, process the resources, etc&amp;#8230;
Determining the &lt;em&gt;task dependencies&lt;/em&gt;, that is to say what other tasks need to be executed, is done by looking up at 3 different things:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;the task &lt;code&gt;dependsOn&lt;/code&gt; dependencies. For example, &lt;code&gt;assemble.dependsOn(jar)&lt;/code&gt; means that if you run &lt;code&gt;assemble&lt;/code&gt;, then the &lt;code&gt;jar&lt;/code&gt; task must be executed before&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;the task &lt;em&gt;transitive dependencies&lt;/em&gt;, in which case we&amp;#8217;re not talking about tasks, but &quot;publications&quot;. For example, when you need to compile project &lt;code&gt;A&lt;/code&gt;, you need on classpath project &lt;code&gt;B&lt;/code&gt;, which implies running &lt;em&gt;some&lt;/em&gt; tasks of &lt;code&gt;B&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;and last but not least, the &lt;em&gt;task inputs&lt;/em&gt;, that is to say, what it needs to execute its work&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In practice, it&amp;#8217;s worth noting that 2. is a subset of 3. but I added it for clarity.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Now let&amp;#8217;s look at this snippet:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint gradle language-gradle&quot;&gt;&lt;code&gt;task docFilesJar(type: Jar, description: &apos;Package up files used for generating documentation.&apos;) {
    archiveVersion = null
    archiveFileName = &quot;grails-doc-files.jar&quot;
    from &quot;src/main/template&quot;
    doLast {
        copy {
            from docFilesJar.archivePath
            into &quot;${buildDir}/classes/groovy/main&quot;
        }
    }
}

jar.dependsOn docFilesJar&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;First, let&amp;#8217;s realize that this snippet is &lt;em&gt;years old&lt;/em&gt;. I mean, very years old, copied from Grails, which was using early releases of Gradle.
Yet, there&amp;#8217;s something interesting in what it does, which is a &lt;strong&gt;typical mistake I see in all builds I modernize&lt;/strong&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;It&amp;#8217;s tempting, especially when you&amp;#8217;re not used to Gradle, to think the same way as other build tools do, like Maven or Ant.
You&amp;#8217;re thinking &quot;there&amp;#8217;s a task, jar, which basically packages everything it finds in &lt;code&gt;classes/groovy/main&lt;/code&gt;, so if I want to add more stuff to the jar task, let&amp;#8217;s put more stuff in &lt;code&gt;classes/groovy/main&lt;/code&gt;&quot;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;strong&gt;This is wrong!&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This is wrong for different reasons, most notably:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;when the &lt;code&gt;docsFilesJar&lt;/code&gt; task is going to be executed, it will contribute more files to the &quot;classes&quot; directory, but, wait, those are not classes that we&amp;#8217;re putting in there, right? It&amp;#8217;s just a jar, resources. Shouldn&amp;#8217;t we use &lt;code&gt;resources/groovy/main&lt;/code&gt; instead? Or is it &lt;code&gt;classes/groovy/resources&lt;/code&gt;? Or what? Well, you &lt;strong&gt;shoudn&amp;#8217;t care&lt;/strong&gt; because it&amp;#8217;s not your concern where the Java compile task is going to put its output!&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;it breaks &lt;em&gt;cacheability&lt;/em&gt;: Gradle has a &lt;em&gt;build cache&lt;/em&gt;, and multiple tasks contributing to the same output directory is the typical example of what would break caching. In fact, it breaks all kinds of up-to-date checking, that is to say the ability for Gradle to understand that it doesn&amp;#8217;t need to execute a task when nothing changed.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;it&amp;#8217;s opaque to Gradle: the code above executes a copy in a &lt;code&gt;doLast&lt;/code&gt; block. Nothing tells Gradle that the &quot;classes&quot; have additional output.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;imagine another task which needs the &lt;code&gt;classes&lt;/code&gt; only. Depending on when it executes, it &lt;em&gt;may&lt;/em&gt; or may not, include the &lt;code&gt;docsFileJar&lt;/code&gt; that it doesn&amp;#8217;t care about. This makes builds non-reproducible (note that this is exactly the reason why Maven build cannot be trusted and that you need to run &lt;code&gt;clean&lt;/code&gt;, because any &quot;goal&quot; can write to any directory at any time, making it impossible to infer who contributed what).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;it requires to declare an &lt;em&gt;explicit dependency&lt;/em&gt; between the &lt;code&gt;jar&lt;/code&gt; task and the &lt;code&gt;docsFileJar&lt;/code&gt; task, to make sure that if we execute &lt;code&gt;jar&lt;/code&gt;, our &quot;docs jar&quot; file is present&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;it doesn&amp;#8217;t tell &lt;em&gt;why&lt;/em&gt; there&amp;#8217;s a dependency: is it because you want to &lt;em&gt;order&lt;/em&gt; things, or is it because you require an &lt;em&gt;artifact&lt;/em&gt; produced by the dependent task? Something else?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;it&amp;#8217;s easy to forget about those: because you may run &lt;code&gt;build&lt;/code&gt; often, you might think that your build works, because &lt;code&gt;jar&lt;/code&gt; is part of the task graph, and &lt;em&gt;by accident&lt;/em&gt;, the &lt;code&gt;docsFileJar&lt;/code&gt; would be executed before&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;it creates accidental extra work: most often a &lt;code&gt;dependsOn&lt;/code&gt; will trigger too much work. Gradle is a smart build tool which can compute &lt;em&gt;precisely&lt;/em&gt; what it needs to execute for each specific task. By using &lt;code&gt;dependsOn&lt;/code&gt;, you&amp;#8217;re a bit using a hammer and forcing it to integrate something in the graph which wasn&amp;#8217;t necessarily needed. In short: you&amp;#8217;re doing too much work.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;it&amp;#8217;s difficult to get rid of them: when you see a &lt;code&gt;dependsOn&lt;/code&gt;, because it doesn&amp;#8217;t tell &lt;em&gt;why&lt;/em&gt; it&amp;#8217;s needed, it&amp;#8217;s often hard to get rid of such dependencies when optimizing builds&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_use_implicit_dependencies_instead&quot;&gt;Use implicit dependencies instead!&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The answer to our problem is actually simpler to reason about: reverse the logic.
Instead of thinking &quot;where should I put those things so that it&amp;#8217;s picked up by jar&quot;, think &quot;let&amp;#8217;s tell the &lt;code&gt;jar&lt;/code&gt; task that it also needs to pick up my resources&quot;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;All in all, it&amp;#8217;s about &lt;em&gt;properly declaring your task inputs&lt;/em&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Instead of patching up the output of another task (seriously, forget about this!), every single task must be thought as a function which takes inputs and produces an output: it&amp;#8217;s &lt;strong&gt;isolated&lt;/strong&gt;.
So, what are the inputs of our &lt;code&gt;docsFileJar&lt;/code&gt;? The resources we want to package. What are its outputs? The &lt;code&gt;jar&lt;/code&gt; itself. There&amp;#8217;s &lt;em&gt;nothing&lt;/em&gt; about where we should put the jar, we let Gradle pick a reasonable place for us.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Then what are the inputs of the &lt;code&gt;jar&lt;/code&gt; task itself? Well, it&amp;#8217;s regular inputs &lt;strong&gt;plus&lt;/strong&gt; our jar. It&amp;#8217;s easier to reason about, and as bonus, it&amp;#8217;s even shorter to write!&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;So let&amp;#8217;s rewrite the code above to:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;task docFilesJar(type: Jar, description: &apos;Package up files used for generating documentation.&apos;) {
    archiveVersion = null
    archiveFileName = &quot;grails-doc-files.jar&quot;
    from &quot;src/main/template&quot;
}

jar {
    from docFilesJar
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Can you spot the difference? We got rid of the &lt;code&gt;copy&lt;/code&gt; in the &lt;code&gt;docFilesJar&lt;/code&gt; task, we don&amp;#8217;t want to do this. What we want, instead, is to say &quot;when you build the jar, also pick this &lt;code&gt;docsFileJar&lt;/code&gt;. And that&amp;#8217;s what we&amp;#8217;re doing by telling &lt;code&gt;from docsFileJar&lt;/code&gt;. Gradle is smart enough to know that when it will need to execute the &lt;code&gt;jar&lt;/code&gt; task, first, it will need to build the &lt;code&gt;docsFilesJar&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;There are several advantages to this:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;the dependency becomes &lt;em&gt;implicit&lt;/em&gt;: if we don&amp;#8217;t want to include the jar anymore, we just have to remove it from the specification of the inputs.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;it doesn&amp;#8217;t pollute the outputs of other tasks&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;you can execute the &lt;code&gt;docsFileJar&lt;/code&gt; independently of &lt;code&gt;jar&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;All in all, it&amp;#8217;s about isolating things from each other and reducing the risks of breaking a build accidentally!&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_all_things_lazy&quot;&gt;All things lazy!&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The modified code isn&amp;#8217;t 2021 compliant. The code above works, but it has one drawback: the &lt;code&gt;docFilesJar&lt;/code&gt; and &lt;code&gt;jar&lt;/code&gt; tasks are going to be configured (instantitated) even if we call something that doesn&amp;#8217;t need it. For example, imagine that you call &lt;code&gt;gradle compileJava&lt;/code&gt;: there&amp;#8217;s no reason to configure the &lt;code&gt;jar&lt;/code&gt; tasks there because we won&amp;#8217;t execute them.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;For this purpose, to make builds faster, Gradle provides a &lt;em&gt;lazy API&lt;/em&gt; instead:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;tasks.register(&apos;docFilesJar&apos;, Jar) {
    description = &apos;Package up files used for generating documentation.&apos;
    archiveVersion = null
    archiveFileName = &quot;grails-doc-files.jar&quot;
    from &quot;src/main/template&quot;
}

tasks.named(&apos;jar&apos;, Jar) {
    from docFilesJar
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_conclusion&quot;&gt;Conclusion&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;As a conclusion:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;avoid using explicit &lt;code&gt;dependsOn&lt;/code&gt; &lt;em&gt;as much as you can&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;I tend to say that the only reasonable use case for &lt;code&gt;dependsOn&lt;/code&gt; is for lifecycle tasks (lifecycle tasks are tasks which goal is only there to &quot;organize the build&quot;, for example &lt;code&gt;build&lt;/code&gt;, &lt;code&gt;assemble&lt;/code&gt;, &lt;code&gt;check&lt;/code&gt;: they don&amp;#8217;t do anything by themselves, they just bind a number of dependents together)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;if you find use cases which are not lifecycle tasks and cannot be expressed by &lt;em&gt;implicit task dependencies&lt;/em&gt; (e.g declaring inputs instead of &lt;code&gt;dependsOn&lt;/code&gt;), then report it to the Gradle team&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>Frequently asked questions about version catalogs</title>
      <link>https://melix.github.io/blog/2021/03/version-catalogs-faq.html</link>
      <pubDate>Sun, 11 Apr 2021 00:00:00 +0200</pubDate>
      <guid isPermaLink="false">2021/03/version-catalogs-faq.html</guid>
      	<description>
	&lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This post is a follow up to my &lt;a href=&quot;/blog/2021/03/version-catalogs.html&quot;&gt;version catalogs intro blog post&lt;/a&gt; and answers some frequently asked questions.
Ideally, this should be part of the Gradle docs itself but we don&amp;#8217;t have a good place for this kind of docs yet (I&amp;#8217;m working on it!), so in the meantime, here you go!
This blog post will be updated as I&amp;#8217;m seeing more questions.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;toc&quot; class=&quot;toc&quot;&gt;
&lt;div id=&quot;toctitle&quot; class=&quot;title&quot;&gt;Table of Contents&lt;/div&gt;
&lt;ul class=&quot;sectlevel1&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_version_catalogs_faq&quot;&gt;Version catalogs FAQ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ul class=&quot;sectlevel2&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_can_i_use_a_version_catalog_to_declare_plugin_versions&quot;&gt;Can I use a version catalog to declare plugin versions?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_can_i_use_the_version_catalog_in_buildsrc&quot;&gt;Can I use the version catalog in buildSrc?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_but_how_can_i_use_the_catalog_in_em_plugins_em_defined_in_code_buildsrc_code&quot;&gt;But how can I use the catalog in &lt;em&gt;plugins&lt;/em&gt; defined in &lt;code&gt;buildSrc&lt;/code&gt;?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_can_i_use_version_catalogs_in_production_code&quot;&gt;Can I use version catalogs in production code?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_should_i_use_a_platform_or_a_catalog&quot;&gt;Should I use a platform or a catalog?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_why_did_you_choose_toml_and_not_yaml&quot;&gt;Why did you choose TOML and not YAML?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_my_ide_is_red_everywhere_missing_dependency_class_error&quot;&gt;My IDE is red everywhere, MISSING_DEPENDENCY_CLASS error&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_why_can_t_i_have_nested_aliases_with_the_same_prefix&quot;&gt;Why can&amp;#8217;t I have nested aliases with the same prefix?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_why_can_t_i_use_an_alias_with_dots_directly&quot;&gt;Why can&amp;#8217;t I use an alias with dots directly?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_should_i_use_code_commons_lang3_code_as_an_alias_or_code_commonslang3_code&quot;&gt;Should I use &lt;code&gt;commons-lang3&lt;/code&gt; as an alias or &lt;code&gt;commonsLang3&lt;/code&gt;?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_should_i_use_the_settings_api_or_the_toml_file&quot;&gt;Should I use the settings API or the TOML file?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_why_can_t_i_use_excludes_or_classifiers&quot;&gt;Why can&amp;#8217;t I use excludes or classifiers?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_how_do_i_tell_gradle_to_use_a_specific_em_artifact_em&quot;&gt;How do I tell Gradle to use a specific &lt;em&gt;artifact&lt;/em&gt;?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_where_should_i_report_bugs_or_feature_requests&quot;&gt;Where should I report bugs or feature requests?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_version_catalogs_faq&quot;&gt;Version catalogs FAQ&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_can_i_use_a_version_catalog_to_declare_plugin_versions&quot;&gt;Can I use a version catalog to declare plugin versions?&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;No.The initial implementation of the version catalogs had, in TOML files, a dedicated section for plugins:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint toml language-toml&quot;&gt;&lt;code&gt;[plugins]
id.of.my.awesome.plugin=&quot;1.2.3&quot;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;However, after community feedback and for &lt;a href=&quot;https://github.com/gradle/gradle/issues/16078&quot;&gt;consistency reasons&lt;/a&gt;, we removed this feature from the initial release.
This means that &lt;em&gt;currently&lt;/em&gt;, you have to use the &lt;code&gt;pluginManagement&lt;/code&gt; section of the settings file to deal with your plugin versions, and this cannot use, in particular, the TOML file to declare plugin versions:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;settings.gradle&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;pluginManagement {
    plugins {
        id(&quot;me.champeau.jmh&quot;) version(&quot;0.6.3&quot;)
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;It may look surprising that you can&amp;#8217;t use &lt;code&gt;version(libs.plugins.jmh)&lt;/code&gt; for example in the &lt;code&gt;pluginManagement&lt;/code&gt; block, but it&amp;#8217;s a chicken and egg problem: the &lt;code&gt;pluginManagement&lt;/code&gt; block has to be evaluated &lt;em&gt;before&lt;/em&gt; the catalogs are defined, because &lt;em&gt;settings plugins&lt;/em&gt; may contribute more catalogs or enhance the existing catalogs. Therefore, the &lt;code&gt;libs&lt;/code&gt; extension doesn&amp;#8217;t exist when this block is evaluated.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The limitation of not being able to deal with plugin versions in catalogs will be lifted in one way or another in the future.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_can_i_use_the_version_catalog_in_buildsrc&quot;&gt;Can I use the version catalog in buildSrc?&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Yes you can. Not only in &lt;code&gt;buildSrc&lt;/code&gt;, but basically in any included build too. You have several options, but the easiest is to include the TOML catalog in your &lt;code&gt;buildSrc/settings.gradle(.kts)&lt;/code&gt; file:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;buildSrc/settings.gradle&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;dependencyResolutionManagement {
    versionCatalogs {
        lib {
            from(files(&quot;../gradle/libs.versions.toml&quot;))
        }
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_but_how_can_i_use_the_catalog_in_em_plugins_em_defined_in_code_buildsrc_code&quot;&gt;But how can I use the catalog in &lt;em&gt;plugins&lt;/em&gt; defined in &lt;code&gt;buildSrc&lt;/code&gt;?&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The solution above lets you use the catalogs in the build scripts of &lt;code&gt;buildSrc&lt;/code&gt; itself, but what if you want to use the catalog(s) in the plugins that &lt;code&gt;buildSrc&lt;/code&gt; defines, or precompiled script plugins?
Long story short, currently, you can do it using a &lt;em&gt;type unsafe&lt;/em&gt; API only.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;First you need to access the version catalogs extension to your plugin/build script, for example in Groovy:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;def catalogs = project.extensions.getByType(VersionCatalogsExtension)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;or in Kotlin:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint kotlin language-kotlin&quot;&gt;&lt;code&gt;val catalogs = extensions.getByType&amp;lt;VersionCatalogsExtension&amp;gt;()&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;then you can access the version catalogs in your script, for example writing:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint kotlin language-kotlin&quot;&gt;&lt;code&gt;pluginManager.withPlugin(&quot;java&quot;) {
    val libs = catalogs.named(&quot;libs&quot;)
    dependencies.addProvider(&quot;implementation&quot;, libs.findDependency(&quot;lib&quot;).get())
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Note that this API doesn&amp;#8217;t provide any static accessor but is nevertheless safe, using the &lt;code&gt;Optional&lt;/code&gt; API.
There&amp;#8217;s a reason why you cannot access type-safe accessors in plugins/precompiled script plugins, you will find more details on this &lt;a href=&quot;https://github.com/gradle/gradle/issues/15383&quot;&gt;issue&lt;/a&gt;.
In a nutshell, that&amp;#8217;s because &lt;code&gt;buildSrc&lt;/code&gt; plugins (precompiled or not) are &lt;em&gt;plugins&lt;/em&gt; which can be applied to any kind of project and we don&amp;#8217;t know what the &lt;em&gt;target project catalogs&lt;/em&gt; will be: there&amp;#8217;s no inherent reason why they would be the same.
In the future we will probably provide a way to explain that, at your own risk, expect the target catalog model to be the same.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_can_i_use_version_catalogs_in_production_code&quot;&gt;Can I use version catalogs in production code?&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;No, you can&amp;#8217;t. Version catalogs are only accessible to build scripts/plugins, not your production code.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_should_i_use_a_platform_or_a_catalog&quot;&gt;Should I use a platform or a catalog?&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;You should probably use both, look at our &lt;a href=&quot;https://docs.gradle.org/7.0/userguide/platforms.html#sub:platforms-vs-catalog&quot;&gt;docs&lt;/a&gt; for a complete explanation.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_why_did_you_choose_toml_and_not_yaml&quot;&gt;Why did you choose TOML and not YAML?&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;or XML (or pick your favorite format). The rationale is described in the &lt;a href=&quot;https://github.com/gradle/gradle/files/5646826/2020-12-05-Central.declaration.of.dependencies.Shared.externally.pdf&quot;&gt;design document&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_my_ide_is_red_everywhere_missing_dependency_class_error&quot;&gt;My IDE is red everywhere, MISSING_DEPENDENCY_CLASS error&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;If you are seeing this error:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;/blog/img/missing-dependency.png&quot; alt=&quot;missing dependency&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;upgrade to the latest IntelliJ IDEA 2021.1, which fixes this problem.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_why_can_t_i_have_nested_aliases_with_the_same_prefix&quot;&gt;Why can&amp;#8217;t I have nested aliases with the same prefix?&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Imagine that you want to have 2 aliases, say &lt;code&gt;junit&lt;/code&gt; and &lt;code&gt;junit-jupiter&lt;/code&gt; and that both represent distinct dependencies: Gradle won&amp;#8217;t let you do this and you will have to rename your aliases to, say &lt;code&gt;junit-core&lt;/code&gt; and &lt;code&gt;junit-jupiter&lt;/code&gt;.
That&amp;#8217;s because Gradle will map those aliases to &lt;em&gt;accessors&lt;/em&gt;, that is to say &lt;code&gt;libs.getJunit()&lt;/code&gt; and &lt;code&gt;libs.getJUnit().getJupiter()&lt;/code&gt;.
The problem is that you can&amp;#8217;t have an accessor which is both a &lt;em&gt;leaf&lt;/em&gt; (represents a dependency notation) and a &lt;em&gt;node&lt;/em&gt; (that is to say an intermediate node to access a real dependency).
The reason we can&amp;#8217;t do this is that we&amp;#8217;re using lazy accessors of type &lt;code&gt;Provider&amp;lt;MinimalExternalDependency&amp;gt;&lt;/code&gt; for leaves and that type &lt;em&gt;cannot&lt;/em&gt; be extended to provide accessors for &quot;children&quot; dependencies.
In other words, the type which represents a &lt;em&gt;node with children&lt;/em&gt; provides accessors which return &lt;code&gt;Provider&amp;lt;...&amp;gt;&lt;/code&gt; for dependencies, but a provider itself cannot have children.
A potential workaround for this would be to support, in the future, an explicit call to say &quot;I&amp;#8217;m stopping here, that&amp;#8217;s the dependency I need&quot;, for example:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;dependencies {
    testImplementation(libs.junit.get())
    // or
    testImplemementation(libs.junit.peek()) // because `get()` might be confusing as it would return a `Provider` on which you can call `get()` itself
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;For now the team has decided to restrict what you can do by preventing having aliases which have &quot;name clashes&quot;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_why_can_t_i_use_an_alias_with_dots_directly&quot;&gt;Why can&amp;#8217;t I use an alias with dots directly?&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;You will have noticed that if you declare an alias like this:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint toml language-toml&quot;&gt;&lt;code&gt;[libraries]
junit-jupiter = &quot;...&quot;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;then Gradle will generate the following accessor: &lt;code&gt;libs.junit.jupiter&lt;/code&gt; (basically the dashes are transformed to dots).
The question is, why can&amp;#8217;t we just write:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint toml language-toml&quot;&gt;&lt;code&gt;[libraries]
junit.jupiter = &quot;...&quot;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;And the reason is: tooling support. The previous declaration is actually equivalent to writing:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint toml language-toml&quot;&gt;&lt;code&gt;[libraries]
   [junit]
   jupiter = &quot;...&quot;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;but technically, it&amp;#8217;s undecidable where the &quot;nesting hierarchy&quot; stops, which would prevent tools from providing good completion (for example, where you can use &lt;code&gt;{ module = &quot;...&quot;}&lt;/code&gt;.
It also makes it harder for tooling to automatically patch the file since they wouldn&amp;#8217;t know where to look for.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;As a consequence, we&amp;#8217;ve decided to keep the format simple and implement this mapping strategy.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_should_i_use_code_commons_lang3_code_as_an_alias_or_code_commonslang3_code&quot;&gt;Should I use &lt;code&gt;commons-lang3&lt;/code&gt; as an alias or &lt;code&gt;commonsLang3&lt;/code&gt;?&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Problably neither one nor the other :) By choosing &lt;code&gt;commons-lang3&lt;/code&gt;, you&amp;#8217;re implicitly creating a &lt;em&gt;group of dependencies&lt;/em&gt; called &lt;code&gt;commons&lt;/code&gt;, which will include a number of dependencies, including &lt;code&gt;lang3&lt;/code&gt;.
The question then is, does that &lt;code&gt;commons&lt;/code&gt; group make sense? It&amp;#8217;s rather abstract, no? Does it actually say it&amp;#8217;s &quot;Apache Commons&quot;?&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;A better solution would therefore be to use &lt;code&gt;commonsLang3&lt;/code&gt; as the alias, but then you&amp;#8217;d realize that you have chosen a version in the alias name, so why not &lt;code&gt;commonsLang&lt;/code&gt; directly?&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Therefore:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint toml language-toml&quot;&gt;&lt;code&gt;[libraries]
commonsLang = { module=&quot;org.apache.commons:commons-lang3:3.3.1&quot; }&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This means that the dashes should be limited to grouping of dependencies, so that they are organized in &quot;folders&quot;.
This can make it practical when you have lots of dependencies, but it also makes them less discoverable by completion, since you&amp;#8217;d have to know in which subtree to look at.
Proper guidance on what to use will be discussed later, based on your feedback and practices.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_should_i_use_the_settings_api_or_the_toml_file&quot;&gt;Should I use the settings API or the TOML file?&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Gradle comes with both a settings API to declare the catalog, or a convenience TOML file.
I would personally say that most people should only care about the TOML file as it covers 80% of use cases.
The settings API is great as soon as you want to implement &lt;em&gt;settings plugins&lt;/em&gt; or, for example, if you want to use your own, existing format to declare a catalog, instead of using the TOML format.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_why_can_t_i_use_excludes_or_classifiers&quot;&gt;Why can&amp;#8217;t I use excludes or classifiers?&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;By design, version catalogs talk about &lt;em&gt;dependency coordinates&lt;/em&gt; only.
The choice of applying excludes is on the consumer side: for example, for a specific project, you might need to exclude a transitive dependency because you don&amp;#8217;t use the code path which exercises this dependency, but this might not be the case for all places.
Similarly, a classifier falls into the category of &lt;em&gt;variant selectors&lt;/em&gt; (see &lt;a href=&quot;https://docs.gradle.org/current/userguide/variant_model.html&quot;&gt;the variant model&lt;/a&gt;): for the same dependency coordinates, one might want classifier X, another classifier Y, and it&amp;#8217;s not necessarily allowed to have both in the same graph.
Therefore, classifiers need to be declared on the &lt;em&gt;dependency declaration site&lt;/em&gt;:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;dependencies {
   implementation(variantOf(libs.myLib) { classifier(&apos;test-fixtures&apos;) })
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The rationale being this limitation is that the use of classifiers is an artifact of the poor &lt;code&gt;pom.xml&lt;/code&gt; modeling, which doesn&amp;#8217;t assign semantics to classifiers (we don&amp;#8217;t know what they represent), contrary to Gradle Module Metadata.
Therefore, a consumer should only care about the dependency coordinates, and the right variant (e.g classifier) should be selected automatically by the dependency resolution engine.
We want to encourage this model, rather than supporting &lt;em&gt;adhoc&lt;/em&gt; classifiers which will eventually require more work for all consumers.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_how_do_i_tell_gradle_to_use_a_specific_em_artifact_em&quot;&gt;How do I tell Gradle to use a specific &lt;em&gt;artifact&lt;/em&gt;?&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Similarly to classifiers or excludes, &lt;em&gt;artifact selectors&lt;/em&gt; belong to the dependency declaration site. You need to write:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;dependencies {
    implementation(libs.myLib) {
        artifact {
            name = &apos;my-lib&apos; // note that ideally this will go away, see https://github.com/gradle/gradle/issues/16768
            type = &apos;aar&apos;
        }
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_where_should_i_report_bugs_or_feature_requests&quot;&gt;Where should I report bugs or feature requests?&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;As usual, on our &lt;a href=&quot;https://github.com/gradle/gradle/issues&quot;&gt;issue tracker&lt;/a&gt;. There&amp;#8217;s also the dedicated &lt;a href=&quot;https://github.com/gradle/gradle/issues/15352&quot;&gt;epic&lt;/a&gt; where you will find the initial specification linked, which explains a lot of the design process.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>Simplified version management with Gradle 7</title>
      <link>https://melix.github.io/blog/2021/03/version-catalogs.html</link>
      <pubDate>Wed, 24 Mar 2021 00:00:00 +0100</pubDate>
      <guid isPermaLink="false">2021/03/version-catalogs.html</guid>
      	<description>
	&lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Gradle 7 introduces the concept of &lt;a href=&quot;https://docs.gradle.org/7.0-rc-1/userguide/platforms.html&quot;&gt;version catalogs&lt;/a&gt;, which I&amp;#8217;ve been working on for several months already. Long story short, I&amp;#8217;m extremely excited by this new feature which should make dependency management easier with Gradle. Let&amp;#8217;s get started!&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;em&gt;Please also read my &lt;a href=&quot;/blog/2021/03/version-catalogs-faq.html&quot;&gt;Version catalogs FAQ&lt;/a&gt; follow up post if you have more questions!&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_sharing_dependencies_between_projects&quot;&gt;Sharing dependencies between projects&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;One of the most frequent questions raised by Gradle users is how to properly share dependency versions between projects.
For example, let&amp;#8217;s imagine that you have a multi-project build with this layout:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;root
 |---- client
 |---- server&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Because they live in the same &quot;multi-project&quot;, it is expected that both &lt;code&gt;client&lt;/code&gt; and &lt;code&gt;server&lt;/code&gt; would require the same dependencies.
For example, both of them would need Guava as an implementation detail and JUnit 5 for testing:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;build.gradle&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;dependencies {
    implementation(&quot;com.google.guava:guava:30.0-jre&quot;)
    testImplementation(&quot;org.junit.jupiter:junit-jupiter-api:5.7.1&quot;)
    testRuntimeOnly(&quot;org.junit.jupiter:junit-jupiter-engine&quot;)
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Without any sharing mechanism, both projects would replicate the dependency declarations, which is subject to a number of drawbacks:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;upgrading a library requires updating all build files which use it&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;you have to remember about the dependency coordinates (group, artifact, version) of all dependencies&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;you might accidentally use different versions in different projects&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;some dependencies are always used together but you have to duplicate entries in build files&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_existing_patterns&quot;&gt;Existing patterns&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;For these reasons, users have invented over the years different patterns for dealing with dependency versions over time.
For example:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Versions in properties files:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;gradle.properties&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;guavaVersion=30.0-jre&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;then in a build file:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;dependencies {
    implementation(&quot;com.google.guava:guava:${guavaVersion}&quot;)
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Or versions in &quot;extra properties&quot; in the root project:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;extra properties&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;ext {
   guavaVersion = &apos;30.0-jre&apos;
}

// ...

dependencies {
    implementation(&quot;com.google.guava:guava:${guavaVersion}&quot;)
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Sometimes you even find full coordinates in &lt;code&gt;dependencies.gradle&lt;/code&gt; files.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;And since the rise of the Kotlin DSL, another pattern became extremely popular in the Android world: declaring libraries in &lt;code&gt;buildSrc&lt;/code&gt; then using type-safe accessors to declare dependencies in build scripts:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;buildSrc/src/main/kotlin/Libs.kt&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint kotlin language-kotlin&quot;&gt;&lt;code&gt;object Libs {
   val guava = &quot;com.google.guava:guava:30.0-jre&quot;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;and in a build script:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;build.gradle&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;dependencies {
    implementation(Libs.guava)
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This last example is interesting because it goes into the direction of having more type-safety, more compile-time errors (as opposed to runtime errors).
But it has a major drawback: any change to any dependency will trigger recompilation of build scripts and invalidate the build script classpath, causing up-to-date checkness to fail and in the end, rebuilding a lot more than what you should do for a single version change.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_introducing_version_catalogs&quot;&gt;Introducing version catalogs&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;A version catalog is basically a replacement for all the previous patterns, supported by Gradle, without the drawbacks of the previous approaches.
To add support for version catalogs, you need to enable the experimental feature in your settings file:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;settings.gradle&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;enableFeaturePreview(&quot;VERSION_CATALOGS&quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In its simplest form, a catalog is a file found in a conventional location and uses the &lt;a href=&quot;https://toml.io/en/&quot;&gt;TOML&lt;/a&gt; configuration format:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;gradle/libs.versions.toml&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint toml language-toml&quot;&gt;&lt;code&gt;[libraries]
guava = &quot;com.google.guava:guava:30.0-jre&quot;
junit-jupiter = &quot;org.junit.jupiter:junit-jupiter-api:5.7.1&quot;
junit-engine = { module=&quot;org.junit.jupiter:junit-jupiter-engine&quot; }

[bundles]
testDependencies = [&quot;junit-jupiter&quot;, &quot;junit-engine&quot;]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This declares the &lt;em&gt;dependency coordinates&lt;/em&gt; which will be used in build scripts.
You still have to declare your dependencies, but this now can be done using a &lt;em&gt;typesafe&lt;/em&gt; API:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;build.gradle&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;dependencies {
    implementation(libs.guava)
    testImplementation(libs.testDependencies)
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The benefit of type-safe APIs is immediately visible in the IDE:&lt;/p&gt;
&lt;/div&gt;
&lt;video controls autoplay height=&quot;450&quot;&gt;
    &lt;source src=&quot;/blog/video/ide-completion.webm&quot;
            type=&quot;video/webm&quot;&gt;
&lt;/video&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In the catalog file above, we inlined dependency versions directly in the coordinates.
However, it&amp;#8217;s possible to externalize them so that you can share a dependency version between dependencies.
For example:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;gradle/libs.versions.toml&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint toml language-toml&quot;&gt;&lt;code&gt;[versions]
groovy = &quot;2.5.14&quot;
guava = &quot;30.0-jre&quot;
jupiter = &quot;5.7.1&quot;

[libraries]
guava = { module=&quot;com.google.guava:guava&quot;, version.ref=&quot;guava&quot; }
junit-jupiter = { module=&quot;org.junit.jupiter:junit-jupiter-api&quot;, version.ref=&quot;jupiter&quot; }
junit-engine = { module=&quot;org.junit.jupiter:junit-jupiter-engine&quot; }

groovy-core = { module=&quot;org.codehaus.groovy:groovy&quot;, version.ref=&quot;groovy&quot; }
groovy-json = { module=&quot;org.codehaus.groovy:groovy-json&quot;, version.ref=&quot;groovy&quot; }

[bundles]
testDependencies = [&quot;junit-jupiter&quot;, &quot;junit-engine&quot;]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This new feature makes it trivial to update a dependency version: you have a single place where to look at.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This comes with other benenefits like the fact that updating the GAV coordinates (group, artifact or version) of a dependency doesn&amp;#8217;t trigger recompilation of build scripts.
The TOML format also provides us with the ability to declare &lt;a href=&quot;https://docs.gradle.org/7.0-rc-1/userguide/rich_versions.html&quot;&gt;rich versions&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_under_the_hood&quot;&gt;Under the hood&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Under the hood, Gradle provides an API to declare catalogs. This API is found on the &lt;code&gt;Settings&lt;/code&gt;, which means that plugin authors can contribute catalogs, for example via convention plugins applied to the &lt;code&gt;settings.gradle(.kts)&lt;/code&gt; file.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This API is more verbose than when you use the TOML file, but is designed for type-safety. The equivalent of the catalog above would be this:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;settings.gradle&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;dependencyResolutionManagement {
   versionCatalogs {
      libs {
           alias(&quot;guava&quot;).to(&quot;com.google.guava&quot;, &quot;guava&quot;).versionRef(&quot;guava&quot;)
           alias(&quot;junit-jupiter&quot;).to(&quot;org.junit.jupiter&quot;, &quot;junit-jupiter-api&quot;).versionRef(&quot;jupiter&quot;)
           alias(&quot;junit-engine&quot;).to(&quot;org.junit.jupiter&quot;, &quot;junit-jupiter-engine&quot;).withoutVersion()
           alias(&quot;groovy-core&quot;).to(&quot;org.codehaus.groovy&quot;, &quot;groovy&quot;).versionRef(&quot;groovy&quot;)
           alias(&quot;groovy-json&quot;).to(&quot;org.codehaus.groovy&quot;, &quot;groovy-json&quot;).versionRef=&quot;groovy&quot;)

           version(&quot;groovy&quot;, &quot;2.5.14&quot;)
           version(&quot;guava&quot;, &quot;30.0-jre&quot;)
           version(&quot;jupiter&quot;, &quot;5.7.1&quot;)
      }
   }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This API actually must be used if you are &lt;em&gt;consuming an external catalog&lt;/em&gt;.
That&amp;#8217;s one of the big selling points of this feature: it allows teams (or framework authors) to &lt;em&gt;publish catalogs&lt;/em&gt;, so that users can get recommendations.
For example, let&amp;#8217;s imagine that the Spring Boot team &lt;a href=&quot;https://docs.gradle.org/7.0-rc-1/userguide/platforms.html#sec:version-catalog-plugin&quot;&gt;publishes a catalog of recommendations&lt;/a&gt; (they do something similar today with a BOM, but BOMs will have an impact on your transitive dependencies that you might not want).&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Consuming this catalog it in a Gradle build would look like this:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;settings.gradle&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;dependencyResolutionManagement {
   versionCatalogs {
       spring {
           from(&quot;org.springframework:spring-catalog:1.0&apos;)
       }
   }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This would make a catalog available under the &lt;code&gt;spring&lt;/code&gt; namespace in your build scripts.
Therefore, you&amp;#8217;d be able to use whatever version of SLF4J the Spring team recommends by declaring this dependency:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;build.gradle&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;dependencies {
    implementation(spring.slf4j)
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Such a catalog would be published on a regular Maven repository, as a TOML file.
Thanks to Gradle&amp;#8217;s advanced dependency resolution engine, it&amp;#8217;s totally transparent to the user that the actual dependency is a &lt;em&gt;catalog&lt;/em&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_what_version_catalogs_are_not&quot;&gt;What version catalogs are not&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;At this stage, it becomes important to state what version catalogs are &lt;strong&gt;not&lt;/strong&gt;:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;they &lt;strong&gt;are not&lt;/strong&gt; the &quot;single source of truth&quot; for your dependencies: it&amp;#8217;s not because you have a catalog that you can&amp;#8217;t directly declare dependencies using the &quot;old&quot; notation in build scripts. Nor does it prevent plugins from adding dependencies. Long story short: the presence of a catalog makes discoverability and maintenance easier, but it doesn&amp;#8217;t remove any of the flexibility that Gradle offers. We&amp;#8217;re thinking about ways to &lt;em&gt;enforce&lt;/em&gt; that all direct dependencies are declared via a catalog in the future.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;the version declared in a catalog &lt;strong&gt;is not&lt;/strong&gt; necessarily the one which is going to be resolved: a catalog only talks about direct dependencies (not transitives) and the version that you use is the one used as an &lt;em&gt;input&lt;/em&gt; to dependency resolution. With transitive dependencies, it&amp;#8217;s typically possible that a version gets upgraded, for example.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;while it makes it possible for third-party tooling to &quot;update automatically&quot; versions, this wasn&amp;#8217;t a goal of this work. If you relate to the previous point, it all makes sense: as long as you rely on the &lt;em&gt;input&lt;/em&gt; (what is written) to assume what is going to be resolved, you&amp;#8217;re only &lt;em&gt;wishing&lt;/em&gt; that it is what is going to be resolved. It may be enough for some cases, though. Please refer to my &lt;a href=&quot;https://melix.github.io/blog/2020/10/about-dependabot.html&quot;&gt;blog post about Dependabot&lt;/a&gt; for more insights on this topic. Again, future work we have in mind is adding some linting to make sure that the first level dependencies you declare match whatever you resolved, because in general, having a difference there is a sign that something is wrong in the setup. I&amp;#8217;m going to repeat myself, but &lt;strong&gt;don&amp;#8217;t assume that the version you see in a config file is the one you will get&lt;/strong&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Please take a look at the &lt;a href=&quot;https://docs.gradle.org/7.0-rc-1/userguide/platforms.html#sub:central-declaration-of-dependencies&quot;&gt;documentation&lt;/a&gt; for further details, and give us your feedback!&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>Using Java 16 with Gradle</title>
      <link>https://melix.github.io/blog/2021/03/gradle-java16.html</link>
      <pubDate>Wed, 17 Mar 2021 00:00:00 +0100</pubDate>
      <guid isPermaLink="false">2021/03/gradle-java16.html</guid>
      	<description>
	&lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://twitter.com/java/status/1371842658256228356&quot;&gt;Java 16 is out&lt;/a&gt; and I&amp;#8217;m seeing a number of folks trying to figure out how to use Java 16 with Gradle.
Often they would try to run Gradle with JDK 16 and see it fail.
There&amp;#8217;s a &lt;a href=&quot;https://github.com/gradle/gradle/issues/13481&quot;&gt;ticket about Java 16 support in Gradle&lt;/a&gt; but in most cases you can already work with JDK 16 without waiting for official support.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_the_happy_path&quot;&gt;The happy path&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Gradle 7, which is due soon, will provide official support for Java 16.
If you have an existing build that you want to try on Java 16, you can update the wrapper to use the latest Gradle 7.0 milestone release:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;gradle/wrapper/gradle-wrapper.properties&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-7.0-milestone-3-bin.zip
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;If you are lucky this is all you need to do.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;However, Gradle 7 is a major release, and as such it brings a number of changes which &lt;em&gt;may&lt;/em&gt; break your build (deprecated methods being removed, or, in particular for the Java 16 support, upgrading to Groovy 3 internally).
It may be a bit involved to migrate to Gradle 7 just to try Java 16.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_decouple_the_java_version_used_for_gradle_itself_from_the_version_you_need&quot;&gt;Decouple the Java version used for Gradle itself from the version you need!&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;It&amp;#8217;s actually better to &lt;em&gt;decouple the version of Java required to run Gradle&lt;/em&gt; from the &lt;em&gt;version of Java your application requires&lt;/em&gt;.
In general, it&amp;#8217;s actually considered the &lt;strong&gt;best practice&lt;/strong&gt; to use whatever version of the JDK Gradle officially supports to run Gradle itself, and configure the build to &lt;strong&gt;use a different JDK&lt;/strong&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_configuring_java_toolchains&quot;&gt;Configuring Java toolchains&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In Gradle terminology, this is called activating &lt;a href=&quot;https://docs.gradle.org/6.8.3/userguide/toolchains.html&quot;&gt;Java Toolchains&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Let&amp;#8217;s get started with a sample project running on latest stable Gradle, which is 6.8.3.
Make sure that you have Gradle 6.8.3 on your PATH to get started.
I&amp;#8217;m personally recommending to use &lt;a href=&quot;https://sdkman.io/&quot;&gt;sdkman!&lt;/a&gt; to install Gradle:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint bash language-bash&quot;&gt;&lt;code&gt;$ sdk install gradle 6.8.3&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;At the same time, we want to make sure we run Gradle with a supported version, which is anything between Java 8 and 15:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint bash language-bash&quot;&gt;&lt;code&gt;$ java -version
java -version
openjdk version &quot;11.0.9.1&quot; 2020-11-04
OpenJDK Runtime Environment 18.9 (build 11.0.9.1+1)
OpenJDK 64-Bit Server VM 18.9 (build 11.0.9.1+1, mixed mode)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;If it outputs something else than 8 to 15, please make sure to update your PATH to point to such a JDK.
Again you can do this with sdkman!:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint bash language-bash&quot;&gt;&lt;code&gt;$ sdk install java 11.0.9.open&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_demo_application&quot;&gt;Demo application&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Now, let&amp;#8217;s create a sample Gradle project:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint bash language-bash&quot;&gt;&lt;code&gt;$ mkdir demo-app
$ cd demo-app
$ gradle init&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Then select:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;Select type of project to generate:
  1: basic
  2: application
  3: library
  4: Gradle plugin
Enter selection (default: basic) [1..4] 2

Select implementation language:
  1: C++
  2: Groovy
  3: Java
  4: Kotlin
  5: Scala
  6: Swift
Enter selection (default: Java) [1..6] 3

Split functionality across multiple subprojects?:
  1: no - only one application project
  2: yes - application and library projects
Enter selection (default: no - only one application project) [1..2] 1

Select build script DSL:
  1: Groovy
  2: Kotlin
Enter selection (default: Groovy) [1..2] 1

Select test framework:
  1: JUnit 4
  2: TestNG
  3: Spock
  4: JUnit Jupiter
Enter selection (default: JUnit 4) [1..4] 4

Project name (default: demo-app):
Source package (default: demo.app):&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;and confirm the default name and packages.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Then let&amp;#8217;s run our app:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint bash language-bash&quot;&gt;&lt;code&gt;$ ./gradlew run

&amp;gt; Task :app:run
Hello World!

BUILD SUCCESSFUL in 4s
2 actionable tasks: 2 executed&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_migrating_the_application_to_java_16&quot;&gt;Migrating the application to Java 16&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;All good! Now let&amp;#8217;s configure Gradle to use Java 16 to build and run our app instead.
Let&amp;#8217;s open the build script, found under &lt;code&gt;app&lt;/code&gt;:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;app/build.gradle&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;plugins {
    // Apply the application plugin to add support for building a CLI application in Java.
    id &apos;application&apos;
}

// Add this under the `plugins` section:
java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(16)
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The &lt;code&gt;java.toolchain&lt;/code&gt; block lets us configure the &lt;em&gt;toolchain&lt;/em&gt; that Gradle is going to use to build and run your application.
We&amp;#8217;re setting 16, which means that we&amp;#8217;re going to compile the main and test sources as well as execute the with a Java 16 JDK.
Gradle will automatically try to find if you have a Java 16 installation in a conventional location.
If it cannot find one you will see something like this happening:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Provisioning toolchain adoptopenjdk-16-x64-linux.tar.gz &amp;gt; adoptopenjdk-16-x64-linux.tar.gz &amp;gt; 66 MiB/195.8 MiB&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;which means that Gradle is downloading the JDK for you!&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Let&amp;#8217;s check:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint bash language-bash&quot;&gt;&lt;code&gt;./gradlew run&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;strong&gt;Dang!&lt;/strong&gt; The &lt;a href=&quot;https://scans.gradle.com/s/gogpwzdj5zf6q/console-log?anchor=14&quot;&gt;build fails!&lt;/a&gt;.
To some extent, it&amp;#8217;s good news, it means that Gradle is really using Java 16, but why is it failing?&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_disabling_incremental_compilation&quot;&gt;Disabling incremental compilation&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Well, you&amp;#8217;re facing one of the bugs we fixed in 7, which is that our &lt;em&gt;incremental compiler&lt;/em&gt; isn&amp;#8217;t compatible with Java 16 because we&amp;#8217;re using classes which have been made &quot;hidden&quot; by the module system in Java 16.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;There&amp;#8217;s an easy fix: let&amp;#8217;s disable incremental compilation!&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Again, let&amp;#8217;s open our &lt;code&gt;app/build.gradle&lt;/code&gt; file and add this:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;tasks.withType(JavaCompile).configureEach {
	// disable incremental compilation
    options.incremental = false
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;And let&amp;#8217;s run the build again:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint bash language-bash&quot;&gt;&lt;code&gt;./gradlew run&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Yay! This time the &lt;a href=&quot;https://scans.gradle.com/s/czapxbvfqxt72/console-log?anchor=7&quot;&gt;build passed!&lt;/a&gt;
Congrats, you have your first Java 16 app running!&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Alternatively to disabling incremental compilation, you might just want to let Gradle access the JDK internals.
This solution is better for performance, even if a bit &quot;hackish&quot;:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;tasks.withType(JavaCompile).configureEach {
    options.forkOptions.jvmArgs.addAll( [&apos;--add-opens&apos;, &apos;jdk.compiler/com.sun.tools.javac.code=ALL-UNNAMED&apos;] )
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In case you want to use one of the experimental features that Java 16 provides, the setup I&amp;#8217;ve described in a &lt;a href=&quot;https://melix.github.io/blog/2020/06/java-feature-previews-gradle.html&quot;&gt;previous post about Java Feature Previews&lt;/a&gt; still hold and is a good follow-up to this post!&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
	</description>
    </item>

  </channel> 
</rss>
